{"version":3,"sources":["../../src/CodeCollapse.ts","../../src/Chunker.ts","../../src/index.ts"],"names":["countTokens","node","chunk","path","read","Parser"],"mappings":"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","file":"index.js","sourcesContent":["import { SyntaxNode } from 'web-tree-sitter';\n\nimport { countTokens } from '@cs/llm-tokenizer';\n\nconst CHUNK_SIZE_BUFFER = 50;\n\nexport const collapsedNodeConstructors: {\n  [key: string]: (\n    node: SyntaxNode,\n    code: string,\n    maxChunkSize: number,\n  ) => Promise<string | { content: string; startLine: number; endLine: number }[]>;\n} = {\n  // Classes, structs, etc\n  class_definition: buildClassChunk,\n  class_declaration: buildClassChunk,\n  impl_item: buildClassChunk,\n  // Functions\n  function_definition: buildNodeChunks,\n  function_declaration: buildNodeChunks,\n  function_item: buildNodeChunks,\n  // Methods\n  method_declaration: buildNodeChunks,\n  method_definition: buildNodeChunks,\n  arrow_function: buildNodeChunks,\n  // Export statement\n  export_statement: buildNodeChunks,\n  program: buildNodeChunks,\n};\n\nconst FUNCTION_BLOCK_NODE_TYPES = ['block', 'statement_block'];\nconst FUNCTION_DECLARATION_NODE_TYPEs = [\n  'method_definition',\n  'function_definition',\n  'function_item',\n  'function_declaration',\n  'method_declaration',\n];\n\nasync function buildClassChunk(node: SyntaxNode, code: string, maxChunkSize: number): Promise<string> {\n  return collapseChildNodes(\n    node,\n    code,\n    ['block', 'class_body', 'declaration_list'],\n    FUNCTION_DECLARATION_NODE_TYPEs,\n    FUNCTION_BLOCK_NODE_TYPES,\n    maxChunkSize,\n  );\n}\n\nasync function collapseChildNodes(\n  node: SyntaxNode,\n  code: string,\n  blockTypes: string[],\n  collapseTypes: string[],\n  collapseBlockTypes: string[],\n  maxChunkSize: number,\n): Promise<string> {\n  code = code.slice(0, node.endIndex);\n  const block = locateFirstChild(node, blockTypes);\n  const collapsedChildren = [];\n\n  if (block) {\n    const childrenToCollapse = block.children.filter((child) => collapseTypes.includes(child.type));\n    for (const child of childrenToCollapse.reverse()) {\n      const grandChild = locateFirstChild(child, collapseBlockTypes);\n      if (grandChild) {\n        const start = grandChild.startIndex;\n        const end = grandChild.endIndex;\n        const collapsedChild = code.slice(child.startIndex, start) + getCollapsePlaceholder(grandChild);\n        code = code.slice(0, start) + getCollapsePlaceholder(grandChild) + code.slice(end);\n\n        collapsedChildren.unshift(collapsedChild);\n      }\n    }\n  }\n  code = code.slice(node.startIndex);\n  let removedChild = false;\n  while (countTokens(code.trim()) > maxChunkSize && collapsedChildren.length > 0) {\n    removedChild = true;\n    // Remove children starting at the end - TODO: Add multiple chunks so no children are missing\n    const childCode = collapsedChildren.pop()!;\n    const index = code.lastIndexOf(childCode);\n    if (index > 0) {\n      code = code.slice(0, index) + code.slice(index + childCode.length);\n    }\n  }\n\n  if (removedChild) {\n    // Remove the extra blank lines\n    let lines = code.split('\\n');\n    let firstWhiteSpaceInGroup = -1;\n    for (let i = lines.length - 1; i >= 0; i--) {\n      if (lines[i].trim() === '') {\n        if (firstWhiteSpaceInGroup < 0) {\n          firstWhiteSpaceInGroup = i;\n        }\n      } else {\n        if (firstWhiteSpaceInGroup - i > 1) {\n          // Remove the lines\n          lines = [...lines.slice(0, i + 1), ...lines.slice(firstWhiteSpaceInGroup + 1)];\n        }\n        firstWhiteSpaceInGroup = -1;\n      }\n    }\n\n    code = lines.join('\\n');\n  }\n\n  return code;\n}\n\nfunction getCollapsePlaceholder(node: SyntaxNode): string {\n  if (node.type === 'statement_block') {\n    return '{ ... }';\n  }\n  return '...';\n}\n\nfunction locateFirstChild(node: SyntaxNode, grammarName: string | string[]): SyntaxNode | null {\n  if (Array.isArray(grammarName)) {\n    return node.children.find((child) => grammarName.includes(child.type)) || null;\n  }\n  return node.children.find((child) => child.type === grammarName) || null;\n}\n\nasync function buildNodeChunks(\n  node: SyntaxNode,\n  code: string,\n  maxChunkSize: number,\n): Promise<{ startLine: number; endLine: number; content: string }[]> {\n  const codeCollapse: { startLine: number; endLine: number; content: string }[] = [];\n  let currentLine = code.slice(0, node.startIndex).split('\\n').length;\n\n  partitionCodeByNode(node, code, maxChunkSize, (chunk) => {\n    const chunkLines = chunk.split('\\n');\n    const startLine = currentLine;\n    const endLine = currentLine + chunkLines.length - 1;\n\n    codeCollapse.push({\n      startLine,\n      endLine,\n      content: chunk,\n    });\n\n    currentLine = endLine + 1;\n  });\n\n  return codeCollapse;\n}\n\nfunction trimLastLine(text: string): string {\n  const lines = text.split('\\n');\n  lines.pop();\n  return lines.join('\\n');\n}\n\nfunction partitionCodeByNode(\n  node: SyntaxNode,\n  code: string,\n  maxChunkSize: number,\n  addChunk: (chunk: string, startIndex: number, endIndex: number) => void,\n): void {\n  let currentChunkStart = node.startIndex;\n  let currentChunkSize = 0;\n  // Buffer to ensure chunks do not exceed the max chunk size limit\n  let safeChunkLimit = maxChunkSize - CHUNK_SIZE_BUFFER;\n\n  function processNode(node: SyntaxNode) {\n    const nodeSize = countTokens(code.slice(node.startIndex, node.endIndex));\n    if (nodeSize > maxChunkSize) {\n      if (node.children.length > 0) {\n        node.children.forEach(processNode);\n      }\n      return;\n    }\n\n    const content = code.slice(currentChunkStart, node.startIndex);\n    // Ensure the chunk remains within the safe size limit before adding\n    if (countTokens(content) > safeChunkLimit) {\n      // The content has an empty line at the end.\n      // Removing only the additionally added empty line\n      // while preserving the empty line added by the user.code\n      addChunk(trimLastLine(content), currentChunkStart, node.startIndex);\n      currentChunkStart = node.startIndex;\n      currentChunkSize = 0;\n    }\n\n    currentChunkSize += nodeSize;\n  }\n\n  node.children.forEach(processNode);\n\n  if (currentChunkSize > 0) {\n    addChunk(code.slice(currentChunkStart, node.endIndex), currentChunkStart, node.endIndex);\n  }\n}\n","import { SyntaxNode } from 'web-tree-sitter';\nimport * as path from 'node:path';\n\nimport { read } from '@cs/context-utils';\nimport Parser from '@cs/tree-sitter';\nimport { countTokens } from '@cs/llm-tokenizer';\n\nimport { collapsedNodeConstructors } from '@lib/CodeCollapse';\nimport { Chunk, ChunkDocumentParam, ChunkMap, ChunkWithoutID, PathAndCacheKey } from '@lib/interface/Chunk';\n\nexport default class Chunker {\n  private cache: Map<string, Chunk[]> = new Map();\n\n  // Maintaining a separate list here to ensure isolation for chunking and code snippets\n  public static supportedLanguages: { [key: string]: string } = {\n    cpp: 'cpp',\n    hpp: 'cpp',\n    cc: 'cpp',\n    cxx: 'cpp',\n    hxx: 'cpp',\n    cp: 'cpp',\n    hh: 'cpp',\n    inc: 'cpp',\n    cs: 'c_sharp',\n    c: 'c',\n    h: 'c',\n    css: 'css',\n    php: 'php',\n    phtml: 'php',\n    php3: 'php',\n    php4: 'php',\n    php5: 'php',\n    php7: 'php',\n    phps: 'php',\n    'php-s': 'php',\n    bash: 'bash',\n    sh: 'bash',\n    json: 'json',\n    ts: 'typescript',\n    mts: 'typescript',\n    cts: 'typescript',\n    tsx: 'tsx',\n    elm: 'elm',\n    js: 'javascript',\n    jsx: 'javascript',\n    mjs: 'javascript',\n    cjs: 'javascript',\n    py: 'python',\n    ipynb: 'python',\n    pyw: 'python',\n    pyi: 'python',\n    el: 'elisp',\n    emacs: 'elisp',\n    ex: 'elixir',\n    exs: 'elixir',\n    go: 'go',\n    eex: 'embedded_template',\n    heex: 'embedded_template',\n    leex: 'embedded_template',\n    html: 'html',\n    htm: 'html',\n    java: 'java',\n    lua: 'lua',\n    ocaml: 'ocaml',\n    ml: 'ocaml',\n    mli: 'ocaml',\n    ql: 'ql',\n    res: 'rescript',\n    resi: 'rescript',\n    rb: 'ruby',\n    erb: 'ruby',\n    rs: 'rust',\n    rdl: 'systemrdl',\n    toml: 'toml',\n    sol: 'solidity',\n    txt: 'txt',\n    md: 'md',\n  };\n\n  private async buildChunkIfFitsLimit(\n    node: SyntaxNode,\n    maxChunkSize: number,\n    root = true,\n  ): Promise<ChunkWithoutID | undefined> {\n    // Keep entire text if not over size\n    if (root || node.type in collapsedNodeConstructors) {\n      const tokenCount = countTokens(node.text);\n      if (tokenCount < maxChunkSize) {\n        return {\n          content: node.text,\n          startLine: node.startPosition.row,\n          endLine: node.endPosition.row,\n        };\n      }\n    }\n    return undefined;\n  }\n\n  private async *walkAndChunk(\n    node: SyntaxNode,\n    code: string,\n    maxChunkSize: number,\n    root = true,\n  ): AsyncGenerator<ChunkWithoutID> {\n    const chunk = await this.buildChunkIfFitsLimit(node, maxChunkSize, root);\n    if (chunk) {\n      yield chunk;\n      return;\n    }\n\n    if (node.type in collapsedNodeConstructors) {\n      const codeCollapse = await collapsedNodeConstructors[node.type](node, code, maxChunkSize);\n      if (typeof codeCollapse === 'string') {\n        yield {\n          content: codeCollapse,\n          startLine: node.startPosition.row,\n          endLine: node.endPosition.row,\n        };\n      } else if (Array.isArray(codeCollapse)) {\n        for (const chunk of codeCollapse) {\n          yield {\n            content: chunk.content,\n            startLine: chunk.startLine,\n            endLine: chunk.endLine,\n          };\n        }\n      }\n    }\n\n    // Recurse (because even if collapsed version was shown, want to show the children in full somewhere)\n    const generators = node.children.map((child) => this.walkAndChunk(child, code, maxChunkSize, false));\n    for (const generator of generators) {\n      yield* generator;\n    }\n  }\n\n  public canBeChunked(pathSep: string, filepath: string, contents: string): boolean {\n    if (contents.length > 1000000) {\n      // if a file has more than 1m characters then skip it\n      // console.log('File has more than 1m characters then skip it.');\n      return false;\n    }\n    if (contents.length === 0) {\n      // console.log('File has 0 characters then skip it.');\n      return false;\n    }\n\n    const basename = filepath.split(pathSep).pop();\n    const extension = path.extname(filepath).slice(1);\n    const languageName = Chunker.supportedLanguages[extension];\n    // Checking the supported language here to avoid unwanted errors during vectorization.\n    if (!languageName) {\n      // console.log(`Chunk: Unsupported language for file: ${filepath}`);\n      return false;\n    }\n\n    // files without extensions are often binary files, skip it if so\n    return basename?.includes('.') ?? false;\n  }\n\n  public async generateChunks(\n    paths: PathAndCacheKey[],\n    pathSep: string,\n    maxChunkSize: number,\n  ): Promise<{ chunkList: Chunk[]; chunkMap: ChunkMap }> {\n    const chunkMap: ChunkMap = new Map();\n    const chunkLists: Chunk[][] = [];\n\n    await Promise.all(\n      paths.map(async (p) => {\n        const cacheKey = `${p.path}_${p.cacheKey}_${pathSep}`;\n\n        if (!this.cache.has(cacheKey)) {\n          const chunks = await this.convertToChunks(p, pathSep, maxChunkSize);\n          this.cache.set(cacheKey, chunks);\n        }\n\n        const cachedChunks = this.cache.get(cacheKey)!;\n        chunkMap.set(p.path, { item: p, chunks: cachedChunks });\n        chunkLists.push(cachedChunks);\n      }),\n    );\n\n    return { chunkList: chunkLists.flat(), chunkMap: chunkMap };\n  }\n\n  public async convertToChunks(\n    pathAndCacheKey: PathAndCacheKey,\n    pathSep: string,\n    maxChunkSize: number,\n  ): Promise<Chunk[]> {\n    const contents = await read(pathAndCacheKey.path);\n    if (!this.canBeChunked(pathSep, pathAndCacheKey.path, contents)) {\n      return [];\n    }\n    const chunks: Chunk[] = [];\n    const chunkParams = {\n      path: pathAndCacheKey.path,\n      contents,\n      maxChunkSize: maxChunkSize,\n      cacheKey: pathAndCacheKey.cacheKey,\n    };\n    for await (const c of this.streamChunk(chunkParams)) {\n      chunks.push(c);\n    }\n    return chunks;\n  }\n\n  public async *streamChunk({ path, contents, maxChunkSize, cacheKey }: ChunkDocumentParam): AsyncGenerator<Chunk> {\n    let index = 0;\n    const chunkPromises: Promise<Chunk | undefined>[] = [];\n    for await (const chunkWithoutId of this.streamChunkWithoutId(path, contents, maxChunkSize)) {\n      chunkPromises.push(\n        new Promise(async (resolve) => {\n          if (countTokens(chunkWithoutId.content) > maxChunkSize) {\n            return resolve(undefined);\n          }\n          resolve({\n            ...chunkWithoutId,\n            cacheKey,\n            index,\n            path,\n          });\n        }),\n      );\n      index++;\n    }\n    for await (const chunk of chunkPromises) {\n      if (!chunk) {\n        continue;\n      }\n      yield chunk;\n    }\n  }\n\n  private async *streamChunkWithoutId(\n    filepath: string,\n    contents: string,\n    maxChunkSize: number,\n  ): AsyncGenerator<ChunkWithoutID> {\n    if (contents.trim() === '') {\n      return;\n    }\n\n    const segs = filepath.split('.');\n    const ext = segs[segs.length - 1];\n    if (ext in Parser.supportedLanguages) {\n      try {\n        for await (const chunk of this.chunkCode(filepath, contents, maxChunkSize)) {\n          yield chunk;\n        }\n        return;\n      } catch (e: any) {\n        // falls back to basicChunker\n        // console.log(e);\n      }\n    }\n\n    yield* this.fallbackChunker(contents, maxChunkSize);\n  }\n\n  public async *fallbackChunker(contents: string, maxChunkSize: number): AsyncGenerator<ChunkWithoutID> {\n    if (contents.trim().length === 0) {\n      return;\n    }\n\n    let chunkContent = '';\n    let chunkTokens = 0;\n    let startLine = 0;\n    let currLine = 0;\n\n    const lineTokens = await Promise.all(\n      contents.split('\\n').map(async (l) => {\n        return {\n          line: l,\n          tokenCount: countTokens(l),\n        };\n      }),\n    );\n\n    for (const lt of lineTokens) {\n      if (chunkTokens + lt.tokenCount > maxChunkSize - 5) {\n        yield { content: chunkContent, startLine, endLine: currLine - 1 };\n        chunkContent = '';\n        chunkTokens = 0;\n        startLine = currLine;\n      }\n\n      if (lt.tokenCount < maxChunkSize) {\n        chunkContent += `${lt.line}\\n`;\n        chunkTokens += lt.tokenCount + 1;\n      }\n\n      currLine++;\n    }\n\n    yield {\n      content: chunkContent,\n      startLine,\n      endLine: currLine - 1,\n    };\n  }\n\n  public async *chunkCode(filepath: string, contents: string, maxChunkSize: number): AsyncGenerator<ChunkWithoutID> {\n    if (contents.trim().length === 0) {\n      return;\n    }\n\n    const fileParser = await Parser.buildParserForFile(filepath);\n    if (fileParser === undefined) {\n      throw new Error(`Failed to load parser for file ${filepath}: `);\n    }\n\n    const tree = fileParser.parse(contents);\n\n    yield* this.walkAndChunk(tree.rootNode, contents, maxChunkSize);\n  }\n}\n","import Chunker from './Chunker';\n\nexport default Chunker;\n"]}