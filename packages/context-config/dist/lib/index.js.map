{"version":3,"sources":["../../src/Config.ts","../../src/index.ts"],"names":["AsyncLocalStorage","config","convict","EmbeddingFactory"],"mappings":";;;;;;;;;;;;AAWA,IAAM,aAAA,GAAgB,IAAIA,6BAAuB,EAAA;AAEjD,IAAM,SAAN,MAAa;AAAA,EACH,iBAAoB,GAAA;AAC1B,IAAA,MAAMC,UAASC,wBAAQ,CAAA;AAAA,MACrB,GAAK,EAAA;AAAA,QACH,GAAK,EAAA,8BAAA;AAAA,QACL,MAAA,EAAQ,CAAC,MAAA,EAAQ,KAAK,CAAA;AAAA,QACtB,OAAS,EAAA,KAAA;AAAA,QACT,GAAK,EAAA;AAAA,OACP;AAAA,MACA,EAAI,EAAA;AAAA,QACF,QAAU,EAAA;AAAA,UACR,GAAK,EAAA;AAAA,YACH,GAAK,EAAA,uBAAA;AAAA,YACL,MAAQ,EAAA,MAAA;AAAA,YACR,OAAS,EAAA,EAAA;AAAA,YACT,GAAK,EAAA;AAAA;AACP;AACF;AACF,KACD,CAAE,CAAA,QAAA,CAAS,EAAE,OAAA,EAAS,UAAU,CAAA;AAEjC,IAAA,OAAOD,QAAO,aAAc,EAAA;AAAA;AAC9B,EAEA,aAAA,CAAc,SAAiB,GAAA,EAAa,EAAA;AAC1C,IAAA,MAAMA,UAAkB,EAAE,GAAG,KAAK,iBAAkB,EAAA,EAAG,GAAG,SAAU,EAAA;AACpE,IAAA,aAAA,CAAc,UAAUA,OAAM,CAAA;AAE9B,IAAOA,OAAAA,OAAAA;AAAA;AACT,EAEA,SAAY,GAAA;AACV,IAAMA,MAAAA,OAAAA,GAAkB,KAAK,YAAa,EAAA;AAC1C,IAAAA,OAAAA,CAAO,oBAAoBE,iCAAiB,CAAA,MAAA;AAAA,MAC5CF,SAAQ,iBAAmB,EAAA,QAAA;AAAA,MACzBA,OAAAA,CAAO,qBAAqB;AAAC,KAC/B;AAEA,IAAOA,OAAAA,OAAAA;AAAA;AACT,EAEA,YAAwB,GAAA;AACtB,IAAMA,MAAAA,OAAAA,GAAS,cAAc,QAAS,EAAA;AACtC,IAAA,IAAI,CAACA,OAAQ,EAAA;AACX,MAAM,MAAA,IAAI,MAAM,8DAA8D,CAAA;AAAA;AAEhF,IAAOA,OAAAA,OAAAA;AAAA;AAEX,CAAA;AAEA,IAAM,MAAA,GAAS,IAAI,MAAO,EAAA;AAC1B,IAAO,cAAQ,GAAA,MAAA;;;AC9Df,IAAO,aAAQ,GAAA","file":"index.js","sourcesContent":["import convict from 'convict';\nimport { AsyncLocalStorage } from 'async_hooks';\n\nimport EmbeddingFactory, { BaseEmbeddingProvider } from '@cs/embedding';\nimport { IConfig, IEmbeddingProvider } from '@lib/interface/Config';\n\n// To access config across multiple deeply nested packages without passing it manually.\n// To isolate configuration for each asynchronous execution flow (e.g. different repos or IDE instances).\n// Each repository or workspace may have its own config (e.g. rootDir, embeddingProvider).\n// When running multiple repos/scripts in parallel (e.g. different IDE tabs), we must avoid config leaks.\n// AsyncLocalStorage ensures that each run retains its own config, even if they execute concurrently.\nconst configContext = new AsyncLocalStorage<any>();\n\nclass Config {\n  private loadConvictConfig() {\n    const config = convict({\n      env: {\n        doc: 'The application environment.',\n        format: ['prod', 'dev'],\n        default: 'dev',\n        env: 'NODE_ENV',\n      },\n      db: {\n        postgres: {\n          URL: {\n            doc: 'Postgres Database URI',\n            format: String,\n            default: '',\n            env: 'POSTGRES_URL',\n          },\n        },\n      },\n    }).validate({ allowed: 'strict' });\n\n    return config.getProperties();\n  }\n\n  loadAppConfig(appConfig: any = {}): IConfig {\n    const config: IConfig = { ...this.loadConvictConfig(), ...appConfig };\n    configContext.enterWith(config);\n\n    return config;\n  }\n\n  getConfig() {\n    const config: IConfig = this.getAppConfig();\n    config.embeddingProvider = EmbeddingFactory.create(\n    config?.embeddingProvider?.provider as IEmbeddingProvider['provider'],\n      config.embeddingProvider ?? {},\n    ) as BaseEmbeddingProvider;\n\n    return config;\n  }\n\n  getAppConfig(): IConfig {\n    const config = configContext.getStore();\n    if (!config) {\n      throw new Error('No config available in current context. Did you call init()?');\n    }\n    return config;\n  }\n}\n\nconst config = new Config();\nexport default config;\n","import config from './Config';\n\nexport default config;\n"]}