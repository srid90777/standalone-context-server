{"version":3,"sources":["../../../../node_modules/p-try/index.js","../../../../node_modules/p-limit/index.js","../../src/llm/BaseLlm.ts","../../src/llm/DelegatedLlm.ts","../../src/llm/LlmFactory.ts","../../src/service/AbstractCodebaseService.ts","../../src/constant/Database.ts","../../src/repository/orm/BaseRepository.ts","../../src/model/orm/GlobalCache.ts","../../src/model/orm/Chunk.ts","../../src/model/orm/CacheReport.ts","../../src/repository/orm/GlobalCacheRepository.ts","../../src/indexer/core/GlobalCacheCodeBaseIndex.ts","../../src/model/orm/Tag.ts","../../src/repository/orm/TagRepository.ts","../../src/model/orm/ChunkTag.ts","../../src/repository/orm/ChunkRepository.ts","../../src/service/ChunkService.ts","../../src/indexer/core/ChunkCodeIndex.ts","../../src/model/orm/Fts.ts","../../src/model/orm/FtsMetadata.ts","../../src/repository/orm/FullTextSearchRepository.ts","../../src/service/FullTextSearchService.ts","../../src/lib/database/AbstractDatabase.ts","../../src/lib/database/Lance.ts","../../src/model/lanceDb/Lance.ts","../../src/model/lanceDb/Tag.ts","../../src/model/orm/LanceCache.ts","../../src/repository/orm/LanceCacheRepository.ts","../../src/service/VectorService.ts","../../src/context/retriever/BaseRetriever.ts","../../src/context/retriever/NoRerankRetriever.ts","../../src/context/retriever/reranker/RerankRetriever.ts","../../src/context/Retriever.ts","../../src/indexer/core/VectorIndex.ts","../../src/indexer/core/FullTextSearchIndex.ts","../../src/model/orm/CodeSnippet.ts","../../src/model/orm/CodeSnippetTag.ts","../../src/repository/orm/CodeSnippetRepository.ts","../../src/service/CodeSnippetService.ts","../../src/indexer/core/CodeSnippetIndex.ts","../../src/service/Process.ts","../../src/constant/Process.ts","../../src/indexer/CodebaseIndexer.ts","../../src/model/orm/index.ts","../../src/lib/database/Sqlite.ts","../../src/script/indexer.ts","../../src/index.ts"],"names":["Model","Column","DataType","Table","crypto","read","plimit","tag","ForeignKey","Op","Chunker","getPathSep","getBasePath","QueryTypes","getLanceDbPath","lancedb","Lance","Tag","uuidv4","getCleanedTrigrams","deduplicateArray","extractKeywords","hasRequiredCpuFeaturesForLanceDb","EmbeddingFactory","config","Sequelize","Parser","AsyncQueue","ChildProcess","isJson","traverseAndClean","getScriptPath","collectAllFiles","getLastModified","progress","writeStats","getWorkspaceDir","getIndexSqlitePath","db","process","indexer"],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\n\nconst pTry = (fn, ...arguments_) => new Promise(resolve => {\n\tresolve(fn(...arguments_));\n});\n\nmodule.exports = pTry;\n// TODO: remove this in the next major version\nmodule.exports.default = pTry;\n","'use strict';\nconst pTry = require('p-try');\n\nconst pLimit = concurrency => {\n\tif (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {\n\t\treturn Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));\n\t}\n\n\tconst queue = [];\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.length > 0) {\n\t\t\tqueue.shift()();\n\t\t}\n\t};\n\n\tconst run = (fn, resolve, ...args) => {\n\t\tactiveCount++;\n\n\t\tconst result = pTry(fn, ...args);\n\n\t\tresolve(result);\n\n\t\tresult.then(next, next);\n\t};\n\n\tconst enqueue = (fn, resolve, ...args) => {\n\t\tif (activeCount < concurrency) {\n\t\t\trun(fn, resolve, ...args);\n\t\t} else {\n\t\t\tqueue.push(run.bind(null, fn, resolve, ...args));\n\t\t}\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.length\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.length = 0;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn generator;\n};\n\nmodule.exports = pLimit;\nmodule.exports.default = pLimit;\n","import { LlmOptions } from '@lib/interface/Llm';\n\nexport class BaseLlm {\n  static llmName: string;\n  model: string | undefined;\n\n  constructor(protected readonly options: LlmOptions) {\n    this.options = options;\n  }\n}\n","import { BaseLlm } from './BaseLlm';\nimport { ChatInput, ILlm } from '@lib/interface/Llm';\n\nexport class DelegatedLlm extends BaseLlm implements ILlm {\n  static llmName = 'DelegatedLlm';\n\n  public async chat(input: ChatInput): Promise<string> {\n    return this.options.invokeFn(input);\n  }\n}\n","import { BaseLlm } from './BaseLlm';\nimport { DelegatedLlm } from './DelegatedLlm';\n\nexport const llms: (typeof BaseLlm)[] = [DelegatedLlm];\n\nexport const getLlmClassFromName = (name: string): typeof BaseLlm | undefined =>\n  llms.find((cls) => cls.llmName === name);\n\nexport class LlmFactory {\n  public static create = (name: string, params?: { [key: string]: any }) => {\n    const llm = getLlmClassFromName(name) as any;\n    if (!llm) {\n      console.warn(`Unknown Llm ${name}`);\n    }\n    return params ? new llm(params) : new llm();\n  };\n}\n","import crypto from 'node:crypto';\nimport plimit from 'p-limit';\n\nimport { read } from '@cs/context-utils';\nimport { GlobalCacheCodeBaseIndex } from '@lib/indexer/core/GlobalCacheCodeBaseIndex';\n\nimport { TagRepository } from '@lib/repository/orm/TagRepository';\nimport { GlobalCacheRepository } from '@lib/repository/orm/GlobalCacheRepository';\nimport { Tag } from '@lib/model/orm/Tag';\n\nimport { ICodebaseService, IndexType, RefreshIndex } from '@lib/interface/Indexer';\nimport { ComputeTag, IndexTag, MarkCompleteCallback } from '@lib/interface/Tag';\nimport { LastModifiedMap, PathAndCacheKey } from '@lib/interface/Types';\n\nconst calculateHash = (fileContents: string): string => {\n  const hash = crypto.createHash('sha256');\n  hash.update(fileContents);\n  return hash.digest('hex');\n};\n\nexport abstract class AbstractCodebaseService implements ICodebaseService {\n  tagRepo: TagRepository;\n  globalCacheRepo: GlobalCacheRepository;\n\n  constructor() {\n    this.tagRepo = new TagRepository();\n    this.globalCacheRepo = new GlobalCacheRepository();\n  }\n\n  public tagToString(tag: IndexTag): string {\n    return `${tag.dir}::${tag.branch}::${tag.artifactId}`;\n  }\n\n  private async computeTag(indexTag: IndexTag, currentFiles: LastModifiedMap, refresh: boolean): Promise<ComputeTag> {\n    const files = { ...currentFiles };\n    const tags = await this.getTags(indexTag);\n    const itemsToUpdate: Tag[] = [];\n    const itemsToDelete: Tag[] = [];\n    const itemsToUpdateTimestamp: Tag[] = [];\n    for (const tag of tags) {\n      const { lastUpdatedAt } = tag;\n\n      if (!refresh && files[tag.path] === undefined) {\n        // Was indexed, but no longer exists. Remove\n        itemsToDelete.push(tag);\n      } else {\n        // Exists in old and new, so determine whether it was updated\n        if (Number(lastUpdatedAt) < files[tag.path]) {\n          // Change was made after last update\n          const newCacheKey = calculateHash(await read(tag.path));\n          if (tag.cacheKey !== newCacheKey) {\n            itemsToDelete.push({ ...tag } as Tag);\n            const newTag = { ...tag } as Tag;\n            newTag.cacheKey = newCacheKey;\n            itemsToUpdate.push(newTag);\n          } else {\n            itemsToUpdateTimestamp.push(tag);\n          }\n        } else {\n          // Already updated, do nothing\n        }\n\n        // Remove so we can check leftovers afterward\n        delete files[tag.path];\n      }\n    }\n\n    const limit = plimit(10);\n    const promises = Object.keys(files).map(async (path) => {\n      const fileContents = await limit(() => read(path));\n      return { path, cacheKey: calculateHash(fileContents), ...indexTag };\n    });\n\n    const itemsToAdd: any = await Promise.all(promises);\n\n    return {\n      add: [...itemsToAdd, ...itemsToUpdate],\n      remove: itemsToDelete,\n      updateLastUpdated: itemsToUpdateTimestamp,\n      markComplete: this.markComplete,\n    };\n  }\n\n  public async getTags(tag: IndexTag): Promise<Tag[]> {\n    return await this.tagRepo.getAll(tag);\n  }\n\n  public async markComplete(tags: Tag[], type: IndexType): Promise<void> {\n    if (tags.length <= 0) {\n      return;\n    }\n\n    const newUpdatedAt = Date.now();\n    const tagRepo = new TagRepository();\n    for (const tag of tags) {\n      switch (type) {\n        case IndexType.Compute:\n        case IndexType.AddTag:\n          tag.lastUpdatedAt = String(newUpdatedAt);\n          await tagRepo.replaceOrInsert(tag);\n          break;\n        case IndexType.RemoveTag:\n        case IndexType.Delete:\n          await tagRepo.delete(tag);\n          break;\n        case IndexType.UpdateLastUpdated:\n          await tagRepo.update(\n            { cacheKey: tag.cacheKey, lastUpdatedAt: String(newUpdatedAt) },\n            { tag, path: tag.path },\n          );\n          break;\n        case IndexType.StatusUpdate:\n          const globalCacheRepo = new GlobalCacheRepository();\n          await globalCacheRepo.flagComplete(tags[0].cacheKey, tags[0].artifactId);\n          break;\n      }\n    }\n  }\n\n  public async identifyChanges(\n    tag: IndexTag,\n    currentFiles: LastModifiedMap,\n    identifier: string,\n    refresh: boolean = false,\n  ): Promise<[RefreshIndex, PathAndCacheKey[], MarkCompleteCallback]> {\n    const { add, remove, updateLastUpdated, markComplete } = await this.computeTag(tag, currentFiles, refresh);\n\n    const compute: Tag[] = [];\n    const del: Tag[] = [];\n    const addTag: Tag[] = [];\n    const removeTag: Tag[] = [];\n\n    for (const tag of add) {\n      const isExist = await this.checkIfCacheExist(tag.cacheKey, tag.artifactId, tag.path);\n      isExist ? addTag.push(tag) : compute.push(tag);\n    }\n\n    for (const tag of remove) {\n      const isExist = await this.checkIfCacheExist(tag.cacheKey, tag.artifactId, tag.path);\n      !isExist ? removeTag.push(tag) : del.push(tag);\n    }\n\n    const globalCacheIndex = await GlobalCacheCodeBaseIndex.create();\n\n    return [\n      { compute, del, addTag, removeTag },\n      updateLastUpdated,\n      async (tags: Tag[], type: IndexType) => {\n        // Update tag\n        await markComplete(tags, type);\n        // Update the global cache\n        const results: any = {\n          compute: [],\n          del: [],\n          addTag: [],\n          removeTag: [],\n        };\n        results[type] = tags;\n        for await (const _ of globalCacheIndex.update(tag, results, identifier, async () => {})) {\n        }\n      },\n    ];\n  }\n\n  private async getTagsFromGlobalCache(cacheKey: string, artifactId: string, path: string): Promise<IndexTag[]> {\n    return await this.globalCacheRepo.getAll(['dir', 'branch', 'artifactId'], { cacheKey, artifactId, path });\n  }\n\n  private async checkIfCacheExist(cacheKey: string, artifactId: string, path: string) {\n    const existingCache = await this.getTagsFromGlobalCache(cacheKey, artifactId, path);\n    return existingCache.length > 0;\n  }\n}\n","//sequelize error code to corresponding messages enum\nexport const SequelizeErrorCode: { [key: string]: string } = {\n  ECONNREFUSED: 'Database connection refused.',\n  EHOSTUNREACH: 'Database host is unreachable.',\n  ETIMEOUT: 'Database connection timeout.',\n  '22P02': 'Invalid input syntax for data type.',\n  '23505': 'Unique constraint violation.',\n  '23502': 'NOT NULL constraint violation.',\n  '23503': 'Foreign key constraint violation.',\n  '23514': 'Validation failed',\n  '42703': 'Undefined column.',\n  '42P01': 'Undefined table.',\n};\n","import { NonNullFindOptions, Attributes, Model } from 'sequelize';\n\nimport { SequelizeErrorCode } from '@lib/constant/Database';\n\nexport class BaseRepository {\n  error(error: any) {\n    return error.name.length ? `${error.name}: ${SequelizeErrorCode[error?.parent?.code]}` : error;\n  }\n\n  getFindOptions(\n    attributes?: string[],\n    conditions?: Record<string, string>,\n    raw: boolean = false,\n  ): NonNullFindOptions<Attributes<Model>> {\n    // With raw: true, Sequelize skips wrapping the result in Sequelize model instances\n    // and directly returns plain JavaScript objects.\n    // For large queries or when working with many rows,\n    // this can significantly reduce memory overhead and improve performance.\n    return {\n      rejectOnEmpty: false,\n      raw,\n      ...(conditions ? { where: conditions } : {}),\n      ...(attributes?.length ? { attributes } : null),\n    };\n  }\n}\n","import { Table, Column, Model, DataType } from 'sequelize-typescript';\n\n@Table({ tableName: 'GlobalCache' })\nexport class GlobalCache extends Model {\n  @Column({ type: DataType.STRING })\n  declare cacheKey: string;\n\n  @Column({ type: DataType.STRING })\n  declare dir: string;\n\n  @Column({ type: DataType.STRING })\n  declare artifactId: string;\n\n  @Column({ type: DataType.STRING })\n  declare branch: string;\n\n  // Include path here as different files may have same content\n  @Column({ type: DataType.STRING })\n  declare path: string;\n\n  @Column({ type: DataType.STRING })\n  declare identifier: string;\n}\n","import { Table, Column, Model, DataType } from 'sequelize-typescript';\n\n@Table({ tableName: 'Chunk' })\nexport class Chunk extends Model {\n  @Column({ type: DataType.STRING })\n  declare cacheKey: string;\n\n  @Column({ type: DataType.STRING })\n  declare path: string;\n\n  @Column({ type: DataType.INTEGER })\n  declare startLine: number;\n\n  @Column({ type: DataType.INTEGER })\n  declare endLine: number;\n\n  @Column({ type: DataType.STRING })\n  declare content: string;\n}\n","import { Table, Column, Model, DataType } from 'sequelize-typescript';\n\n@Table({ tableName: 'CacheReport' })\nexport class CacheReport extends Model {\n  @Column({ type: DataType.STRING })\n  declare identity: string;\n\n  @Column({ type: DataType.STRING })\n  declare artifactId: string;\n\n  @Column({ type: DataType.STRING })\n  declare status: string;\n}\n","import { Attributes, NonNullFindOptions, Optional } from 'sequelize';\n\nimport { BaseRepository } from './BaseRepository';\n\nimport { GlobalCache } from '@lib/model/orm/GlobalCache';\nimport { Chunk } from '@lib/model/orm/Chunk';\nimport { GlobalIndex } from '@lib/interface/Indexer';\nimport { CacheReport } from '@lib/model/orm/CacheReport';\n\nexport class GlobalCacheRepository extends BaseRepository {\n  public async getAll(attributes?: string[], conditions?: Record<string, string>, raw: boolean = false) {\n    const options: NonNullFindOptions<Attributes<GlobalCache>> = this.getFindOptions(attributes, conditions, raw);\n\n    return await GlobalCache.findAll(options);\n  }\n\n  public async getLatest(attributes?: string[], conditions?: Record<string, string>, raw: boolean = false) {\n    const options: NonNullFindOptions<Attributes<GlobalCache>> = this.getFindOptions(attributes, conditions, raw);\n    options.order = [['updatedAt', 'DESC']];\n    const globalCache = (await GlobalCache.findOne(options)) ?? {};\n    let chunk: Partial<Chunk> = {};\n\n    if (Object.keys(globalCache).length > 0) {\n      const chunkOptions: NonNullFindOptions<Attributes<Chunk>> = this.getFindOptions(\n        [],\n        { cacheKey: globalCache.cacheKey },\n        raw,\n      );\n      chunk = await Chunk.findOne(chunkOptions);\n    }\n\n    return Object.assign({}, chunk, globalCache);\n  }\n\n  public async replace(tag: GlobalIndex): Promise<void> {\n    const tagValue = {\n      cacheKey: tag.cacheKey,\n      dir: tag.dir,\n      branch: tag.branch,\n      artifactId: tag.artifactId,\n      path: tag.path,\n      identifier: tag.identifier,\n    };\n    await GlobalCache.upsert(tagValue);\n  }\n\n  public async delete(conditions: Record<string, any>) {\n    await GlobalCache.destroy({ where: conditions });\n  }\n\n  private async getAllReport(attributes?: string[], conditions?: Record<string, string>, raw: boolean = false) {\n    const options: NonNullFindOptions<Attributes<CacheReport>> = this.getFindOptions(attributes, conditions, raw);\n\n    return await CacheReport.findAll(options);\n  }\n\n  public async flagComplete(identity: string, artifactId: string) {\n    await this.addStatus({ identity, artifactId, status: 'done' });\n  }\n\n  private async addStatus(data: Partial<CacheReport>) {\n    await CacheReport.create(data);\n  }\n\n  public async getCompleted(identity: string, artifactId: string) {\n    return await this.getAllReport([], { identity, artifactId, status: 'done' }, true);\n  }\n\n  public async getCompletedIndexbyIdentity(identity: string) {\n    return await this.getAllReport([], { identity, status: 'done' }, true);\n  }\n}\n","import { GlobalCacheRepository } from '@lib/repository/orm/GlobalCacheRepository';\n\nimport { GlobalIndex, ICodebaseIndex, IndexProgressUpdate, LatestChunk, RefreshIndex } from '@lib/interface/Indexer';\nimport { IndexTag, MarkCompleteCallback } from '@lib/interface/Tag';\nimport { LastModifiedMap } from '@lib/interface/Types';\n\nexport class GlobalCacheCodeBaseIndex implements ICodebaseIndex {\n  private artifactId = 'globalCache';\n  private repo: GlobalCacheRepository;\n  constructor() {\n    this.repo = new GlobalCacheRepository();\n  }\n\n  public getArtifactId() {\n    return this.artifactId;\n  }\n\n  static async create(): Promise<GlobalCacheCodeBaseIndex> {\n    return new GlobalCacheCodeBaseIndex();\n  }\n\n  public async *update(\n    indexTag: IndexTag,\n    refreshIndex: RefreshIndex,\n    identifier: string,\n    _: MarkCompleteCallback,\n  ): AsyncGenerator<IndexProgressUpdate, any, unknown> {\n    const add = [...refreshIndex.compute, ...refreshIndex.addTag];\n    const remove = [...refreshIndex.del, ...refreshIndex.removeTag];\n    await Promise.all([\n      ...remove.map((tag) => {\n        return this.deleteOrRemoveTag({ ...tag, identifier });\n      }),\n      ...add.map((tag) => {\n        return this.computeOrAddTag({ ...tag, identifier });\n      }),\n    ]);\n    yield { progress: 1, desc: 'Done updating global cache', status: 'done' };\n  }\n\n  private async computeOrAddTag(tag: GlobalIndex): Promise<void> {\n    await this.repo.replace(tag);\n  }\n\n  private async deleteOrRemoveTag(tag: GlobalIndex): Promise<void> {\n    await this.repo.delete({\n      cacheKey: tag.cacheKey,\n      dir: tag.dir,\n      branch: tag.branch,\n      artifactId: tag.artifactId,\n      path: tag.path,\n      identifier: tag.identifier,\n    });\n  }\n\n  public identifyChanges(tag: IndexTag, currentFiles: LastModifiedMap): Promise<any> {\n    throw new Error('Method not implemented.');\n  }\n\n  public async getLatestChunk(dir: string, branch: string): Promise<LatestChunk | {}> {\n    const lastCachedFile = await this.repo.getLatest([], { dir, branch }, true);\n    if (Object.keys(lastCachedFile).length === 0) {\n      return {};\n    }\n\n    return {\n      path: lastCachedFile.path as string,\n      indexedAt: lastCachedFile.updatedAt,\n    };\n  }\n\n  public async get(identifier: string, artifactId: string) {\n    return await this.repo.getAll([], { identifier, artifactId }, true);\n  }\n\n  public async getCompleted(identifier: string, artifactId: string) {\n    return await this.repo.getCompleted(identifier, artifactId);\n  }\n\n  public async getCompletedCount(identifier: string) {\n    return (await this.repo.getCompletedIndexbyIdentity(identifier)).length;\n  }\n}\n","import { Table, Column, Model, DataType } from 'sequelize-typescript';\n\n@Table({ tableName: 'Tag' })\nexport class Tag extends Model<Tag> {\n  @Column({ type: DataType.STRING })\n  declare dir: string;\n\n  @Column({ type: DataType.STRING })\n  declare branch: string;\n\n  @Column({ type: DataType.STRING })\n  declare artifactId: string;\n\n  @Column({ type: DataType.STRING })\n  declare path: string;\n\n  @Column({ type: DataType.STRING })\n  declare cacheKey: string;\n\n  @Column({ type: DataType.STRING })\n  declare lastUpdatedAt: string;\n\n  @Column({ type: DataType.STRING, allowNull: true })\n  declare projectId?: string | undefined;\n\n  @Column({ type: DataType.INTEGER, allowNull: true })\n  declare orgId?: number | undefined;\n\n  @Column({ type: DataType.INTEGER, allowNull: true })\n  declare tenantId?: number | undefined;\n}\n","import { Attributes, NonNullFindOptions, Optional } from 'sequelize';\nimport { NullishPropertiesOf } from 'sequelize/types/utils';\n\nimport { BaseRepository } from './BaseRepository';\nimport { Tag } from '@lib/model/orm/Tag';\nimport { IndexTag } from '@lib/interface/Tag';\nimport { Chunk } from '@lib/model/orm/Chunk';\n\nexport class TagRepository extends BaseRepository {\n  private getWhereCondition(tag: IndexTag, extraConditions?: Record<string, string>) {\n    const whereCondition = Object.fromEntries(\n      Object.entries({\n        dir: tag.dir,\n        branch: tag.branch,\n        artifactId: tag.artifactId,\n        projectId: tag.projectId,\n        tenantId: tag.tenantId,\n        org: tag.orgId,\n      }).filter(([_, value]) => value != null), // Filter out null or undefined values\n    );\n    return {\n      where: {\n        ...whereCondition,\n        ...extraConditions,\n      },\n    };\n  }\n\n  async getAll(tag?: IndexTag): Promise<Tag[]> {\n    const findOptions = tag ? this.getWhereCondition(tag) : {};\n\n    return await Tag.findAll(findOptions);\n  }\n\n  async update(updateFields: Record<string, any>, conditions: Record<string, any>): Promise<void> {\n    const { tag, ...extraConditions } = conditions;\n\n    await Tag.update(updateFields, this.getWhereCondition(tag, extraConditions));\n  }\n\n  async replaceOrInsert(tag: Tag): Promise<void> {\n    const chunk = await Chunk.findOne({\n      where: { cacheKey: tag.cacheKey, path: tag.path },\n      raw: true,\n    });\n\n    if (chunk) {\n      await Tag.upsert(tag as Optional<Tag, NullishPropertiesOf<Tag>>);\n    }\n  }\n\n  async delete(tag: Tag): Promise<void> {\n    const extraConditions = { path: tag.path, cacheKey: tag.cacheKey };\n    await Tag.destroy(this.getWhereCondition(tag, extraConditions));\n  }\n}\n","import { Table, Column, Model, DataType, ForeignKey } from 'sequelize-typescript';\n\nimport { Chunk } from './Chunk';\n\n@Table({ tableName: 'ChunkTag' })\nexport class ChunkTag extends Model {\n  @Column({ type: DataType.STRING })\n  declare tagString: string;\n\n  @ForeignKey(() => Chunk)\n  @Column({ type: DataType.INTEGER })\n  declare chunkId: number;\n}\n","import { NonNullFindOptions, Attributes, Op } from 'sequelize';\n\nimport { BaseRepository } from './BaseRepository';\nimport { ChunkTag } from '@lib/model/orm/ChunkTag';\nimport { Chunk } from '@lib/model/orm/Chunk';\n\nimport { PathAndCacheKey } from '@lib/interface/Types';\n\nexport class ChunkRepository extends BaseRepository {\n  public async getAll(attributes?: string[], conditions?: Record<string, string>, raw: boolean = false) {\n    const options: NonNullFindOptions<Attributes<Chunk>> = this.getFindOptions(attributes, conditions, raw);\n\n    return await Chunk.findAll(options);\n  }\n\n  public async get(attributes?: string[], conditions?: Record<string, string>, raw: boolean = false) {\n    const options: NonNullFindOptions<Attributes<Chunk>> = this.getFindOptions(attributes, conditions, raw);\n\n    return await Chunk.findOne(options);\n  }\n\n  public async bulkAdd(chunks: Partial<Chunk>[], tagString: string): Promise<void> {\n    const transaction = await Chunk.sequelize?.transaction();\n    try {\n      // Bulk insert chunks\n      const createdChunks = await Chunk.bulkCreate(chunks, {\n        returning: true,\n        transaction,\n      });\n\n      // Create corresponding tags\n      const chunkTags = createdChunks.map((chunk) => ({\n        chunkId: chunk.id,\n        tagString,\n      }));\n\n      await ChunkTag.bulkCreate(chunkTags, {\n        transaction,\n        ignoreDuplicates: true, // Optional: prevents duplicate tag errors\n      });\n\n      await transaction?.commit();\n    } catch (error) {\n      await transaction?.rollback();\n      throw new Error('Error inserting chunks with tags', { cause: error });\n    }\n  }\n\n  /**\n   * Replacement for \"bulkAdd\"\n   * bulkAdd - Ensures that either all rows are inserted or none.\n   * If any insert fails, the transaction rolls back completely and no partial data is saved.\n   * addChunksWithTags - Supports partial inserts If inserting a chunk or its tags fails, the rest will still be attempted.\n   *\n   * @param chunks\n   * @param tagString\n   */\n  public async addChunksWithTags(chunks: Partial<Chunk>[], tagString: string): Promise<void> {\n    for (const chunk of chunks) {\n      try {\n        const createdChunk = await Chunk.create(chunk);\n        try {\n          await ChunkTag.create({ chunkId: createdChunk.id, tagString });\n        } catch (tagError) {\n          // console.error(`Failed to insert tag for chunk ID ${createdChunk.id}:`, tagError);\n        }\n      } catch (chunkError) {\n        // console.error('Failed to insert chunk:', chunkError);\n      }\n    }\n  }\n\n  public async addChunkTags(pathAndCacheKey: PathAndCacheKey, tagString: string) {\n    const chunks = await this.getAll([], pathAndCacheKey);\n    if (chunks.length === 0) {\n      // console.log(`No chunks found for path ${pathAndCacheKey.path} and cache ${pathAndCacheKey.cacheKey}.`);\n      return;\n    }\n    const chunkTags = chunks.map((chunk) => ({ chunkId: chunk.id, tagString: tagString }));\n    await ChunkTag.bulkCreate(chunkTags);\n  }\n\n  private async deleteChunkTag(conditions: Record<string, any>) {\n    await ChunkTag.destroy({ where: conditions });\n  }\n\n  private async deleteChunk(conditions: Record<string, any>) {\n    await Chunk.destroy({ where: conditions });\n  }\n\n  public async deleteChunkTags(pathAndCacheKey: PathAndCacheKey, tagString: string): Promise<void> {\n    const chunkIds = await this.getAll(['id'], pathAndCacheKey, true).then((chunks) => chunks.map((chunk) => chunk.id));\n\n    if (chunkIds.length > 0) {\n      await this.deleteChunkTag({ tagString, chunkId: { [Op.in]: chunkIds } });\n    }\n  }\n\n  public async delete(cacheKey: string) {\n    const chunksToDelete = await this.getAll(['id'], { cacheKey }, true);\n\n    for (const chunkToDelete of chunksToDelete) {\n      const chunkId = chunkToDelete.id;\n      await this.deleteChunkTag({ chunkId });\n      await this.deleteChunk({ id: chunkId });\n    }\n  }\n\n  public async getAllByChunkIds(ids: number[]) {\n    return await Chunk.findAll({ where: { id: { [Op.in]: ids } } });\n  }\n}\n","import Chunker from '@cs/chunker';\nimport { getBasePath, getPathSep } from '@cs/context-utils';\n\nimport { AbstractCodebaseService } from './AbstractCodebaseService';\n\nimport { ChunkRepository } from '@lib/repository/orm/ChunkRepository';\nimport { Tag } from '@lib/model/orm/Tag';\n\nimport { MarkCompleteCallback } from '@lib/interface/Tag';\nimport { IndexProgressUpdate, IndexType, RefreshIndex, SyncChunk } from '@lib/interface/Indexer';\n\nexport class ChunkService extends AbstractCodebaseService {\n  private chunkRepo: ChunkRepository;\n  private maxChunkSize: number;\n\n  constructor(maxChunkSize: number) {\n    super();\n    this.chunkRepo = new ChunkRepository();\n    this.maxChunkSize = maxChunkSize;\n  }\n\n  async *sync(syncContext: SyncChunk) {\n    yield* this.processChunkTags(IndexType.AddTag, syncContext);\n    yield* this.processChunkTags(IndexType.RemoveTag, syncContext);\n    yield* this.processChunkTags(IndexType.Delete, syncContext);\n  }\n\n  async computeAndAddChunks(tags: Tag[], tagString: string, markComplete: MarkCompleteCallback): Promise<void> {\n    const chunker = new Chunker();\n    const chunks = await chunker.generateChunks(tags, getPathSep(), this.maxChunkSize);\n    await this.chunkRepo.addChunksWithTags(chunks.chunkList, tagString);\n    await markComplete(tags, IndexType.Compute);\n  }\n\n  private async *processChunkTags(indexType: IndexType, syncContext: SyncChunk): AsyncGenerator<IndexProgressUpdate> {\n    let { refreshIndex, tagString, markComplete, accumulatedProgress } = syncContext;\n    const tags = refreshIndex[indexType as keyof RefreshIndex];\n\n    if (!tags.length) {\n      return;\n    }\n\n    for (const tag of tags) {\n      const pathAndCacheKey = { path: tag.path, cacheKey: tag.cacheKey };\n      try {\n        switch (indexType) {\n          case IndexType.AddTag:\n            await this.chunkRepo.addChunkTags(pathAndCacheKey, tagString);\n            break;\n          case IndexType.RemoveTag:\n            await this.chunkRepo.deleteChunkTags(pathAndCacheKey, tagString);\n            break;\n          case IndexType.Delete:\n            await this.chunkRepo.delete(tag.cacheKey);\n            break;\n          default:\n            throw new Error(`Unsupported index type: ${indexType}`);\n        }\n\n        await markComplete([tag], indexType);\n        accumulatedProgress += 1 / tags.length / 4; // Update progress incrementally\n\n        yield {\n          progress: accumulatedProgress,\n          status: 'indexing',\n          desc: `${indexType} ${getBasePath(tag.path)}`,\n        };\n      } catch (error) {\n        // console.log(error);\n        console.error(`Failed to process tag: ${tag.path} for index type: ${indexType}`);\n      }\n    }\n  }\n}\n","import { ChunkService } from '@lib/service/ChunkService';\nimport { ICodebaseIndex, IndexProgressUpdate, RefreshIndex } from '@lib/interface/Indexer';\nimport { LastModifiedMap } from '@lib/interface/Types';\nimport { IndexTag, MarkCompleteCallback } from '@lib/interface/Tag';\n\nexport class ChunkCodeIndex implements ICodebaseIndex {\n  private chunkService: ChunkService;\n  static artifactId: string = 'chunks';\n\n  constructor(private readonly maxChunkSize: number) {\n    this.chunkService = new ChunkService(this.maxChunkSize);\n  }\n\n  public async identifyChanges(tag: IndexTag, currentFiles: LastModifiedMap, identifier: string, refresh: boolean) {\n    return await this.chunkService.identifyChanges(tag, currentFiles, identifier, refresh);\n  }\n\n  public getArtifactId() {\n    return ChunkCodeIndex.artifactId;\n  }\n\n  public async *update(\n    tag: IndexTag,\n    refreshIndex: RefreshIndex,\n    _: string,\n    markComplete: MarkCompleteCallback,\n  ): AsyncGenerator<IndexProgressUpdate, any, unknown> {\n    let accumulatedProgress = 0;\n    const tagString = this.chunkService.tagToString(tag);\n\n    try {\n      if (refreshIndex.compute.length > 0) {\n        yield {\n          desc: `Chunking files`,\n          status: 'indexing',\n          progress: accumulatedProgress,\n        };\n        await this.chunkService.computeAndAddChunks(refreshIndex.compute, tagString, markComplete);\n      }\n\n      for await (const progress of this.chunkService.sync({\n        refreshIndex,\n        tagString,\n        markComplete,\n        accumulatedProgress,\n      })) {\n        yield {\n          desc: progress.desc,\n          progress: progress.progress,\n          status: 'indexing',\n        };\n      }\n    } catch (error) {\n      // console.error('Error during chunk index process:', error);\n    }\n  }\n}\n","import { Table, Column, Model, DataType } from 'sequelize-typescript';\n\n@Table({ tableName: 'Fts' })\nexport class Fts extends Model {\n  static skipSync: boolean = true;\n\n  @Column({ type: DataType.STRING })\n  declare path: string;\n\n  @Column({ type: DataType.STRING })\n  declare content: string;\n\n  @Column({ type: DataType.STRING })\n  declare cacheKey: string;\n}\n","import { Table, Column, Model, DataType, ForeignKey } from 'sequelize-typescript';\n\nimport { Chunk } from './Chunk';\n\n@Table({ tableName: 'FtsMetadata' })\nexport class FtsMetadata extends Model {\n  @Column({ type: DataType.STRING })\n  declare cacheKey: string;\n\n  @Column({ type: DataType.STRING })\n  declare path: string;\n\n  @ForeignKey(() => Chunk)\n  @Column({ type: DataType.INTEGER })\n  declare chunkId: number;\n}\n","import { QueryTypes } from 'sequelize';\n\nimport { BaseRepository } from './BaseRepository';\n\nimport { Fts } from '@lib/model/orm/Fts';\nimport { FtsMetadata } from '@lib/model/orm/FtsMetadata';\n\nconst PATH_WEIGHT_MULTIPLIER = 10.0;\n\nexport class FullTextSearchRepository extends BaseRepository {\n  async insertFts(fts: Record<string, any>) {\n    const ftsEntry = await Fts.create(fts);\n    return ftsEntry.id;\n  }\n\n  async upsertFtsMetadata(ftsMeta: Record<string, any>) {\n    await FtsMetadata.upsert(ftsMeta);\n  }\n\n  public async deleteFts(conditions: Record<string, any>) {\n    await Fts.destroy({ where: conditions });\n  }\n\n  public async deleteFtsMetadata(conditions: Record<string, any>) {\n    await FtsMetadata.destroy({ where: conditions });\n  }\n\n  private buildRetrieveQuery(tagStrings: string[]): string {\n    return `\n      SELECT FtsMetadata.chunkId, FtsMetadata.path, Fts.content, rank\n      FROM Fts\n      JOIN FtsMetadata ON Fts.rowid = FtsMetadata.id\n      JOIN ChunkTag ON FtsMetadata.chunkId = ChunkTag.chunkId\n      WHERE fts MATCH ?\n      AND ChunkTag.tagString IN (${tagStrings.map(() => '?').join(',')})\n      ORDER BY bm25(fts, ${PATH_WEIGHT_MULTIPLIER})\n      LIMIT ?\n    `;\n  }\n\n  public async retrieve(text: string, tagStrings: string[], threshold: number) {\n    const query = this.buildRetrieveQuery(tagStrings);\n    const parameters = [text.replace(/\\?/g, ''), ...tagStrings, Math.ceil(threshold)];\n\n    const results =\n      (await Fts.sequelize?.query(query, {\n        replacements: parameters,\n        type: QueryTypes.SELECT,\n      })) || [];\n\n    return results;\n  }\n}\n","import { getBasePath } from '@cs/context-utils';\n\nimport { AbstractCodebaseService } from './AbstractCodebaseService';\nimport { ChunkCodeIndex } from '@lib/indexer/core/ChunkCodeIndex';\n\nimport { FullTextSearchRepository } from '@lib/repository/orm/FullTextSearchRepository';\nimport { ChunkRepository } from '@lib/repository/orm/ChunkRepository';\n\nimport { Tag } from '@lib/model/orm/Tag';\nimport { Chunk } from '@lib/model/orm/Chunk';\n\nimport { RefreshIndex, IndexType } from '@lib/interface/Indexer';\nimport { BranchAndDir, MarkCompleteCallback } from '@lib/interface/Tag';\n\nconst RANK_CUTOFF = 15;\nexport class FullTextSearchService extends AbstractCodebaseService {\n  private ftsRepo: FullTextSearchRepository;\n  private chunkRepo: ChunkRepository;\n\n  constructor() {\n    super();\n    this.ftsRepo = new FullTextSearchRepository();\n    this.chunkRepo = new ChunkRepository();\n  }\n\n  public async *processIndexing(refreshIndex: RefreshIndex, markComplete: MarkCompleteCallback) {\n    yield* this.add(refreshIndex.compute, markComplete);\n    await this.addTag(refreshIndex.addTag, markComplete);\n    await this.removeTag(refreshIndex.removeTag, markComplete);\n    await this.delete(refreshIndex.del, markComplete);\n  }\n\n  private async *add(computeTags: Tag[], markComplete: MarkCompleteCallback) {\n    for (let i = 0; i < computeTags.length; i++) {\n      const item = computeTags[i];\n\n      try {\n        // Retrieve chunks for the current tag\n        const chunks = await this.chunkRepo.getAll([], { path: item.path, cacheKey: item.cacheKey }, true);\n\n        // Process each chunk concurrently\n        await Promise.all(\n          chunks.map(async (chunk) => {\n            const id = await this.ftsRepo.insertFts({\n              path: item.path,\n              cacheKey: item.cacheKey,\n              content: chunk.content,\n            });\n            await this.ftsRepo.upsertFtsMetadata({\n              id: id,\n              path: item.path,\n              cacheKey: item.cacheKey,\n              chunkId: chunk.id,\n            });\n          }),\n        );\n\n        yield {\n          progress: i / computeTags.length,\n          desc: `Indexing ${getBasePath(item.path)}`,\n          status: 'indexing',\n        };\n\n        // Mark the current tag as complete\n        await markComplete([item], IndexType.Compute);\n      } catch (error) {\n        // console.error(`Error processing tag: ${item.path}`, error);\n      }\n    }\n  }\n\n  private async addTag(addTags: Tag[], markComplete: MarkCompleteCallback) {\n    if (addTags.length > 0) {\n      // Batch processing for addTag\n      await markComplete(addTags, IndexType.AddTag);\n    }\n  }\n\n  private async removeTag(removeTags: Tag[], markComplete: MarkCompleteCallback) {\n    if (removeTags.length > 0) {\n      // Batch processing for removeTag\n      await markComplete(removeTags, IndexType.RemoveTag);\n    }\n  }\n\n  private async delete(delTags: Tag[], markComplete: MarkCompleteCallback) {\n    for (const item of delTags) {\n      try {\n        // Delete FTS metadata and entry\n        await Promise.all([\n          this.ftsRepo.deleteFtsMetadata({ path: item.path, cacheKey: item.cacheKey }),\n          this.ftsRepo.deleteFts({ path: item.path, cacheKey: item.cacheKey }),\n        ]);\n\n        // Mark the current tag as deleted\n        await markComplete([item], IndexType.Delete);\n      } catch (error) {\n        // console.error(`Error deleting tag: ${item.path}`, error);\n      }\n    }\n  }\n\n  public async get(text: string, tags: BranchAndDir[], threshold: number): Promise<Chunk[]> {\n    const ftsResult = await this.ftsRepo.retrieve(text, this.convertTags(tags), threshold);\n    const filteredResult = (ftsResult as any).filter((result: any) => result.rank <= -2.5);\n    if (filteredResult.length === 0) {\n      return [];\n    }\n\n    // 1.3) Filter by Score\n    const thresholdRank = filteredResult[0].rank + RANK_CUTOFF;\n    const chunkIds = filteredResult.map((result: any) => thresholdRank > result.rank && result.chunkId);\n\n    return await this.chunkRepo.getAllByChunkIds(chunkIds);\n  }\n\n  private convertTags(tags: BranchAndDir[]): string[] {\n    // Notice that the \"chunks\" artifactId is used because of linking between tables\n    return tags.map((tag) => this.tagToString({ ...tag, artifactId: ChunkCodeIndex.artifactId }));\n  }\n}\n","import { Sequelize } from 'sequelize';\nimport { IDatabase } from '@lib/interface/Database';\n\nexport abstract class AbstractDatabase implements IDatabase {\n  protected db: Sequelize | undefined;\n  static modelLocaton: string = '';\n\n  abstract connect(connStringorDbPath: string): Promise<void>;\n\n  public get(): Sequelize | undefined {\n    return this.db;\n  }\n\n  protected logSuccess(): void {\n    // console.log(`${this.constructor.name} connected successfully.`);\n  }\n\n  protected logFailure(e: unknown): void {\n    console.error(`${this.constructor.name} connection Failed: ${e}`);\n  }\n}\n","import * as lancedb from '@lancedb/lancedb';\nimport { getLanceDbPath } from '@cs/context-utils';\n\nimport { AbstractDatabase } from './AbstractDatabase';\n\nexport class Lance extends AbstractDatabase {\n  public async connect(dbPath: string = getLanceDbPath()): Promise<any> {\n    try {\n      return await lancedb.connect(dbPath);\n    } catch (e: any) {\n      this.logFailure(e);\n    }\n  }\n}\n","import { Table } from '@lancedb/lancedb';\n\nimport { Lance as LanceDb } from '@lib/lib/database/Lance';\n\nexport abstract class Lance {\n  private client: any;\n  protected tableName: string = '';\n\n  protected constructor(tableName: string | null = null) {\n    this.connect();\n    if (tableName) {\n      this.tableName = tableName;\n    }\n  }\n\n  private connect() {\n    if (!this.client) {\n      this.client = new LanceDb().connect();\n    }\n  }\n\n  public async createTable(data = {}): Promise<Table> {\n    return await (await this.client).createTable(this.tableName, data);\n  }\n\n  public async listTables() {\n    return await (await this.client).tableNames();\n  }\n\n  private async getTable() {\n    return await (await this.client).openTable(this.tableName);\n  }\n\n  public async add(data: any) {\n    try {\n      const table = await this.getTable();\n      await table.add(data);\n    } catch (err: any) {\n      console.log('err while adding lance data', err);\n    }\n  }\n\n  public async delete(filter: string) {\n    const table = await this.getTable();\n    await table.delete(filter);\n  }\n\n  public async search(input: number[], limit: number) {\n    const table = await this.getTable();\n    return await table.search(input).limit(limit).toArray();\n  }\n}\n","import { Lance } from './Lance';\n\nexport class Tag extends Lance {\n  constructor(tableName?: string) {\n    super(tableName);\n  }\n\n  setTagName(name: string) {\n    this.tableName = name;\n  }\n\n  async isTagExist(tagTblName: string) {\n    const existingTables = await this.listTables();\n    return existingTables.includes(tagTblName);\n  }\n}\n","import { Table, Column, Model, DataType } from 'sequelize-typescript';\n\n@Table({ tableName: 'LanceCache' })\nexport class LanceCache extends Model {\n  @Column({ type: DataType.STRING })\n  declare uuid: string;\n\n  @Column({ type: DataType.STRING })\n  declare cacheKey: string;\n\n  @Column({ type: DataType.STRING })\n  declare path: string;\n\n  @Column({ type: DataType.STRING })\n  declare artifactId: string;\n\n  @Column({ type: DataType.STRING })\n  declare vector: string;\n\n  @Column({ type: DataType.INTEGER })\n  declare startLine: number;\n\n  @Column({ type: DataType.INTEGER })\n  declare endLine: number;\n\n  @Column({ type: DataType.STRING })\n  declare contents: string;\n}\n","import { Attributes, NonNullFindOptions, Op } from 'sequelize';\n\nimport { BaseRepository } from './BaseRepository';\nimport { LanceCache } from '@lib/model/orm/LanceCache';\nimport { LanceDbRow } from '@lib/interface/Indexer';\n\nexport class LanceCacheRepository extends BaseRepository {\n  public async getAll(attributes?: string[], conditions?: Record<string, string>, raw: boolean = false) {\n    const options: NonNullFindOptions<Attributes<LanceCache>> = this.getFindOptions(attributes, conditions, raw);\n\n    return await LanceCache.findAll(options);\n  }\n\n  public async getAllByUuid(uuids?: string[]) {\n    return await LanceCache.findAll({ where: { uuid: { [Op.in]: uuids } } });\n  }\n\n  public async delete(conditions: Record<string, any>) {\n    await LanceCache.destroy({ where: conditions });\n  }\n\n  public async add(rows: LanceDbRow[]): Promise<void> {\n    // const transaction = await LanceCache.sequelize?.transaction();\n\n    // if (!transaction) {\n    //   throw new Error('Unable to start a transaction');\n    // }\n\n    try {\n      for (const row of rows) {\n        await LanceCache.create(\n          {\n            uuid: row.uuid,\n            cacheKey: row.cachekey,\n            path: row.path,\n            artifactId: row.artifactId,\n            vector: JSON.stringify(row.vector),\n            startLine: row.startLine,\n            endLine: row.endLine,\n            contents: row.contents,\n          },\n          // { transaction },\n        );\n      }\n      // await transaction.commit();\n    } catch (error) {\n      // await transaction.rollback();\n      // console.error('Error inserting rows into lance_db_cache', { cause: error });\n    }\n  }\n}\n","import { v4 as uuidv4 } from 'uuid';\n\nimport Chunker from '@cs/chunker';\nimport { getBasePath, getPathSep } from '@cs/context-utils';\n\nimport { AbstractCodebaseService } from './AbstractCodebaseService';\nimport { BaseEmbeddingProvider } from '@cs/embedding';\n\nimport { Tag } from '@lib/model/lanceDb/Tag';\nimport { Tag as TagIndex } from '@lib/model/orm/Tag';\nimport { LanceCacheRepository } from '@lib/repository/orm/LanceCacheRepository';\n\nimport { BranchAndDir, IndexTag, MarkCompleteCallback } from '@lib/interface/Tag';\nimport { Chunk, ChunkMap, IndexType, LanceDbRow, RefreshIndex } from '@lib/interface/Indexer';\nimport { PathAndCacheKey } from '@lib/interface/Types';\n\ninterface State {\n  shouldSkipTableCreation: boolean;\n}\n\nconst DISTANCE_CUTOFF = 1;\nexport class VectorService extends AbstractCodebaseService {\n  private embeddingProvider: BaseEmbeddingProvider;\n  private lanceCacheRepo: LanceCacheRepository;\n  private tag: Tag;\n  private artifactId: string;\n  private maxChunkSize: number;\n  private tagBatchSize = 2;\n  private computeBatchSize = 10;\n\n  constructor(embeddingProvider: BaseEmbeddingProvider, artifactId: string, maxChunkSize: number = 500) {\n    super();\n    this.embeddingProvider = embeddingProvider;\n    this.artifactId = artifactId;\n    this.maxChunkSize = maxChunkSize;\n    this.lanceCacheRepo = new LanceCacheRepository();\n    this.tag = new Tag();\n  }\n\n  private tableNameForTag(tag: IndexTag) {\n    return this.tagToString(tag).replace(/[^\\w-_.]/g, '');\n  }\n\n  private async collectChunks(items: PathAndCacheKey[]): Promise<{ chunkList: Chunk[]; chunkMap: ChunkMap }> {\n    const chunker = new Chunker();\n    return chunker.generateChunks(items, getPathSep(), this.maxChunkSize);\n  }\n\n  private async getEmbeddings(chunks: Chunk[]): Promise<number[][]> {\n    try {\n      return await this.embeddingProvider.embed(chunks.map((c) => c.content));\n    } catch (err) {\n      // console.error(`Failed to generate embeddings for ${chunks.length} chunks with embedding provider: ${err}`, {\n      //   cause: err,\n      // });\n      return [];\n    }\n  }\n\n  private async filterChunks(allChunks: Chunk[]) {\n    const filteredChunks: Chunk[] = [];\n    for (const chunk of allChunks) {\n      const conditions = {\n        contents: chunk.content,\n        startLine: String(chunk.startLine),\n        endLine: String(chunk.endLine),\n      };\n      try {\n        const lanceCache = await this.lanceCacheRepo.getAll([], conditions, true);\n        if (lanceCache.length === 0) {\n          filteredChunks.push(chunk);\n        }\n      } catch (err: any) {\n        // console.error(`Failed to fetch chunk content`, err);\n      }\n    }\n\n    return filteredChunks;\n  }\n\n  private async computeRows(items: PathAndCacheKey[], state: State) {\n    const chunkMap = (await this.collectChunks(items)).chunkMap;\n    const allChunks = await this.filterChunks(Array.from(chunkMap.values()).flatMap(({ chunks }) => chunks));\n\n    for (let i = 0; i < allChunks.length; i += this.computeBatchSize) {\n      const batchChunks = allChunks.slice(i, i + this.computeBatchSize);\n      try {\n        const embeddings = await this.getEmbeddings(batchChunks);\n        for (let j = embeddings.length - 1; j >= 0; j--) {\n          if (embeddings[j] === undefined) {\n            const chunk = batchChunks[j];\n            const chunks = chunkMap.get(chunk.path)?.chunks;\n\n            if (chunks) {\n              const index = chunks.findIndex((c) => c === chunk);\n              if (index !== -1) {\n                chunks.splice(index, 1);\n              }\n            }\n\n            embeddings.splice(j, 1);\n          }\n        }\n        const computedRows = this.formatRows(batchChunks, embeddings);\n        await this.lanceCacheRepo.add(computedRows);\n        if (computedRows.length > 0) {\n          state.shouldSkipTableCreation ? await this.tag.add(computedRows) : await this.tag.createTable(computedRows);\n          state.shouldSkipTableCreation = true;\n        }\n      } catch (err) {\n        // console.error(`Failed to process batch ${Math.floor(i / this.computeBatchSize) + 1}`, err);\n        // break; // Would exit the loop, stopping processing of all remaining batche, so commenting it\n      }\n    }\n  }\n\n  private formatRows(chunks: Chunk[], embeddings: number[][]): LanceDbRow[] {\n    const rows: LanceDbRow[] = [];\n    let embeddingIndex = 0;\n\n    for (const chunk of chunks) {\n      rows.push({\n        path: chunk.path,\n        cachekey: chunk.cacheKey,\n        uuid: uuidv4(),\n        vector: embeddings[embeddingIndex],\n        startLine: chunk.startLine,\n        endLine: chunk.endLine,\n        contents: chunk.content,\n        artifactId: this.artifactId,\n      });\n      embeddingIndex++;\n    }\n\n    return rows;\n  }\n\n  public async *processIndexing(tag: IndexTag, refreshIndex: RefreshIndex, markComplete: MarkCompleteCallback) {\n    const tableName = this.tableNameForTag(tag);\n    let state = { shouldSkipTableCreation: await this.tag.isTagExist(tableName) };\n    let accumulatedProgress = 0;\n    this.tag.setTagName(tableName);\n\n    await this.computeAndAddRows(refreshIndex.compute, state, markComplete);\n    yield* this.addTag(refreshIndex.addTag, state, markComplete, accumulatedProgress);\n    yield* this.removeTag(refreshIndex, markComplete, accumulatedProgress);\n  }\n\n  private async cleanupMemory() {\n    if (global.gc) {\n      global.gc();\n    }\n    await new Promise((resolve) => setTimeout(resolve, 10));\n  }\n\n  private async computeAndAddRows(tags: TagIndex[], state: State, markComplete: MarkCompleteCallback) {\n    for (let i = 0; i < tags.length; i += this.tagBatchSize) {\n      const tagBatch = tags.slice(i, i + this.tagBatchSize);\n      await this.computeRows(tagBatch, state);\n      await markComplete(tagBatch, IndexType.Compute);\n      await this.cleanupMemory();\n    }\n  }\n\n  private async *addTag(\n    addTag: TagIndex[],\n    state: State,\n    markComplete: MarkCompleteCallback,\n    accumulatedProgress: number,\n  ) {\n    for (const tag of addTag) {\n      const { path, cacheKey } = tag;\n      const cachedItems = await this.lanceCacheRepo.getAll(\n        [],\n        {\n          cacheKey,\n          path,\n          artifactId: this.artifactId,\n        },\n        true,\n      );\n      const lanceRows: LanceDbRow[] = cachedItems.map(({ uuid, vector, startLine, endLine, contents }) => ({\n        path,\n        uuid,\n        startLine,\n        endLine,\n        contents,\n        cachekey: cacheKey,\n        vector: JSON.parse(vector),\n        artifactId: this.artifactId,\n      }));\n      if (lanceRows.length > 0) {\n        if (!state.shouldSkipTableCreation) {\n          await this.tag.createTable(lanceRows);\n          state.shouldSkipTableCreation = true;\n        } else {\n          await this.tag.add(lanceRows);\n        }\n      }\n\n      await markComplete([tag], IndexType.AddTag);\n      accumulatedProgress += 1 / addTag.length / 3;\n      yield {\n        progress: accumulatedProgress,\n        desc: `Indexing ${getBasePath(path)}`,\n        status: 'indexing',\n      };\n    }\n  }\n\n  private async *removeTag(\n    refreshIndex: RefreshIndex,\n    markComplete: MarkCompleteCallback,\n    accumulatedProgress: number,\n  ) {\n    const toDel = [...refreshIndex.removeTag, ...refreshIndex.del];\n\n    for (const { path, cacheKey } of toDel) {\n      await this.tag.delete(`cachekey = '${cacheKey}' AND path = '${path}'`);\n      accumulatedProgress += 1 / toDel.length / 3;\n      yield {\n        progress: accumulatedProgress,\n        desc: `Stashing ${getBasePath(path)}`,\n        status: 'indexing',\n      };\n    }\n\n    await markComplete(refreshIndex.removeTag, IndexType.RemoveTag);\n\n    for (const { path, cacheKey } of refreshIndex.del) {\n      await this.lanceCacheRepo.delete({ cacheKey, path, artifactId: this.artifactId });\n      accumulatedProgress += 1 / refreshIndex.del.length / 3;\n      yield {\n        progress: accumulatedProgress,\n        desc: `Removing ${getBasePath(path)}`,\n        status: 'indexing',\n      };\n    }\n\n    await markComplete(refreshIndex.del, IndexType.Delete);\n  }\n\n  public async get(input: string, tags: BranchAndDir[], threshold: number) {\n    const [vector] = await this.embeddingProvider.embed([input]);\n    let allResults: any[] = [];\n    for (const tag of tags) {\n      const results = await this.getByTag({ ...tag, artifactId: this.artifactId }, threshold, vector);\n      allResults.push(...results);\n    }\n\n    if (allResults.length === 0) {\n      return [];\n    }\n\n    // 1.2) Filter by Score: Instead of selecting a fixed number of chunks by sorting scores,\n    // retrieve chunks based on a fixed score threshold.\n    // This helps avoid removing relevant chunks without considering their scores.\n    // const chunkIds = filteredResult.map((result: any) => result.chunkId);\n    // allResults = allResults.sort((a, b) => a._distance - b._distance).slice(0, threshold);\n    allResults = allResults.sort((a, b) => a._distance - b._distance);\n    allResults = allResults.map(\n      (result: any) => allResults[0]?._distance + DISTANCE_CUTOFF > result._distance && result,\n    );\n\n    return await this.getMatchedRows(allResults);\n  }\n\n  private async getMatchedRows(vectors: LanceDbRow[]) {\n    const uuids = vectors.map((r) => r.uuid);\n    const data = await this.lanceCacheRepo.getAllByUuid(uuids);\n\n    return data.map((d) => {\n      return {\n        id: d.id,\n        cacheKey: d.cacheKey,\n        path: d.path,\n        startLine: d.startLine,\n        endLine: d.endLine,\n        index: 0,\n        content: d.contents,\n      };\n    });\n  }\n\n  private async getByTag(tag: IndexTag, limit: number, vector: number[]): Promise<LanceDbRow[]> {\n    const tableName = this.tableNameForTag(tag);\n    if (!(await this.tag.isTagExist(tableName))) {\n      // console.warn('Table not found in LanceDB', tableName);\n      return [];\n    }\n\n    this.tag.setTagName(tableName);\n    return await this.tag.search(vector, limit);\n  }\n}\n","import Chunker from '@cs/chunker';\nimport { deduplicateArray, getCleanedTrigrams, read, extractKeywords } from '@cs/context-utils';\n\nimport { FullTextSearchService } from '@lib/service/FullTextSearchService';\nimport { VectorService } from '@lib/service/VectorService';\n\nimport { Chunk } from '@lib/model/orm/Chunk';\n\nimport { Chunk as ChunkInterface } from '@lib/interface/Indexer';\nimport { BranchAndDir } from '@lib/interface/Tag';\nimport { RetrieverOptions } from '@lib/interface/Retriever';\n\nexport class BaseRetriever {\n  private ftsService: FullTextSearchService;\n  private vectorService: VectorService;\n  private chunker: Chunker;\n\n  constructor(protected readonly options: RetrieverOptions) {\n    this.vectorService = new VectorService(\n      options.embeddingProvider,\n      `vectordb:${options.embeddingProvider.getProviderName()}`,\n    );\n    this.ftsService = new FullTextSearchService();\n    this.chunker = new Chunker();\n  }\n\n  protected async retrieveFts(input: string, tags: BranchAndDir[], threshold: number): Promise<Chunk[]> {\n    try {\n      if (input.trim() === '') {\n        return [];\n      }\n\n      const tokens = getCleanedTrigrams(input).join(' OR ');\n      return await this.ftsService.get(tokens, tags, threshold);\n    } catch (e) {\n      // console.warn('Error retrieving from FTS:', e);\n      return [];\n    }\n  }\n\n  protected async chunkRecentlyEditedFiles(files: string[], threshold: number): Promise<ChunkInterface[]> {\n    const recentlyEditedFilesSlice = files.slice(0, threshold);\n    const chunks: ChunkInterface[] = [];\n    let i = 0;\n    for (const filepath of recentlyEditedFilesSlice) {\n      const contents = await read(filepath);\n      const fileChunks = this.chunker.streamChunk({\n        path: filepath,\n        contents,\n        maxChunkSize: this.options.embeddingProvider.maxChunkSize,\n        cacheKey: filepath,\n      });\n\n      for await (const chunk of fileChunks) {\n        chunks.push({ id: `rc-${++i}`, ...chunk });\n      }\n    }\n\n    return chunks.slice(0, threshold);\n  }\n\n  protected async retrieveEmbeddings(\n    input: string,\n    tags: BranchAndDir[],\n    threshold: number,\n  ): Promise<ChunkInterface[]> {\n    try {\n      return this.vectorService.get(input, tags, threshold);\n    } catch (e) {\n      // console.log('Error retrieving from Embedding:', e);\n      return [];\n    }\n  }\n\n  protected deduplicateChunks(chunks: Partial<Chunk>[]): Partial<Chunk>[] {\n    return deduplicateArray(chunks, (a, b) => {\n      return a.path === b.path && a.startLine === b.startLine && a.endLine === b.endLine;\n    });\n  }\n\n  protected async filter(input: string, chunks: Partial<Chunk>[]) {\n    try {\n      const data = await this.options.llm.chat({ code_chunks: chunks, question: input });\n\n      return JSON.parse(data);\n    } catch (err: any) {\n      // console.error('Err in retrieving data from llm', err);\n\n      return chunks.map((chunk) => chunk.id);\n    }\n  }\n\n  public removeStopWords(input: string): string[] {\n    return extractKeywords(input);\n  }\n}\n","import { hasRequiredCpuFeaturesForLanceDb } from '@cs/context-utils';\nimport { BaseRetriever } from './BaseRetriever';\nimport { Chunk } from '@lib/model/orm/Chunk';\n\nimport { RetrieverArgs } from '@lib/interface/Retriever';\n\nexport class NoRerankRetriever extends BaseRetriever {\n  async retrieve(args: RetrieverArgs) {\n    const { thresholdFinal } = this.options;\n    const recentlyEditedThreshold = thresholdFinal * 0.25;\n    // const ftsThreshold = thresholdFinal * 0.25;\n    // const embeddingsThreshold = thresholdFinal - recentlyEditedThreshold - ftsThreshold;\n    // 1.1) Filter by Score: Instead of selecting a fixed number of chunks by sorting scores,\n    // retrieve chunks based on a fixed score threshold.\n    // This helps avoid removing relevant chunks without considering their scores.\n    const ftsThreshold = 50;\n    const embeddingsThreshold = 50;\n    let chunks: Partial<Chunk>[] = [];\n\n    const { input, tags, recentlyEditedFiles } = args;\n\n    const ftsChunks = await this.retrieveFts(input, tags, ftsThreshold);\n    const embeddingsChunks = hasRequiredCpuFeaturesForLanceDb()\n      ? await this.retrieveEmbeddings(input, tags, embeddingsThreshold)\n      : [];\n\n    const recentlyEditedFilesChunks = await this.chunkRecentlyEditedFiles(recentlyEditedFiles, recentlyEditedThreshold);\n    chunks.push(...recentlyEditedFilesChunks, ...ftsChunks, ...embeddingsChunks);\n    chunks = this.deduplicateChunks(chunks);\n\n    // Filter the chunks based on the question by LLM and get the filtered chunk IDs\n    const filteredChunksIds = await this.filter(input, chunks);\n\n    // LLM output may be either a string or an array of numbers\n    return chunks.filter((item) => filteredChunksIds.includes(String(item.id)) || filteredChunksIds.includes(item.id));\n  }\n}\n","import { BaseRetriever } from '@lib/context/retriever/BaseRetriever';\nimport { RetrieverArgs } from '@lib/interface/Retriever';\n\nexport class RerankRetriever extends BaseRetriever {\n  async retrieve(args: RetrieverArgs) {\n    throw new Error('Method not implemented.');\n  }\n}\n","import EmbeddingFactory from '@cs/embedding';\n\nimport { LlmFactory } from '@lib/llm/LlmFactory';\n\nimport { NoRerankRetriever } from './retriever/NoRerankRetriever';\nimport { RerankRetriever } from './retriever/reranker/RerankRetriever';\n\nimport { RetrievalChainOptions } from '@lib/interface/Retriever';\n\nconst DEFAULT_THRESHOLD = 25;\nconst IS_KEYWORD_RETRIEVAL_ENABLED = true;\n\nexport async function* retrieve(options: RetrievalChainOptions) {\n  const { llm, embeddingName, reRank } = options;\n  const thresholdFinal = options?.thresholdFinal ?? DEFAULT_THRESHOLD;\n  const isKeywordRetrievalEnabled = options?.isKeywordRetrievalEnabled ?? IS_KEYWORD_RETRIEVAL_ENABLED;\n  const retrieverClass = !!reRank ? RerankRetriever : NoRerankRetriever;\n  const retriever = new retrieverClass({\n    thresholdFinal: thresholdFinal,\n    embeddingProvider: EmbeddingFactory.create(embeddingName),\n    llm: LlmFactory.create(llm.name, llm.options),\n  });\n\n  yield {\n    desc: 'retrieveing',\n    action: 'retrieve',\n    status: 'in-progress',\n  };\n\n  if (isKeywordRetrievalEnabled) {\n    const keywords = retriever.removeStopWords(options.input);\n    yield {\n      desc: 'retrieveing relavent keywords',\n      action: 'keywork-lookup',\n      status: 'done',\n      data: keywords,\n    };\n  }\n\n  yield {\n    desc: 'retrieveing relavant files',\n    action: 'retrieve-files',\n    status: 'in-progress',\n  };\n\n  const retrievedResult = await retriever.retrieve({\n    input: options.input,\n    tags: options.tags,\n    recentlyEditedFiles: options.recentlyEditedFiles,\n  });\n\n  yield {\n    desc: 'retrieveing relavant files completed',\n    action: 'retrieve',\n    status: 'complete',\n    data: retrievedResult,\n  };\n}\n","import config from '@cs/context-config';\n\nimport { VectorService } from '@lib/service/VectorService';\nimport { ICodebaseIndex, RefreshIndex } from '@lib/interface/Indexer';\nimport { LastModifiedMap } from '@lib/interface/Types';\nimport { IndexTag } from '@lib/interface/Tag';\n\nexport class VectorIndex implements ICodebaseIndex {\n  private artifactId: string = `vectordb:${config.getConfig().embeddingProvider.getProviderName()}`;\n  private vectorService: VectorService;\n\n  constructor(private readonly maxChunkSize: number) {\n    this.vectorService = new VectorService(config.getConfig().embeddingProvider, this.artifactId, this.maxChunkSize);\n  }\n\n  public getArtifactId() {\n    return this.artifactId;\n  }\n\n  public async *update(tag: IndexTag, subResult: RefreshIndex, _: string, markComplete: any) {\n    const indexingProcess = this.vectorService.processIndexing(tag, subResult, markComplete);\n\n    try {\n      for await (const progress of indexingProcess) {\n        yield progress;\n      }\n    } catch (error) {\n      // console.error('Error during vector index process:', error);\n    }\n  }\n\n  public async identifyChanges(tag: IndexTag, currentFiles: LastModifiedMap, identifier: string, refresh: boolean) {\n    return await this.vectorService.identifyChanges(tag, currentFiles, identifier, refresh);\n  }\n}\n","import { FullTextSearchService } from '@lib/service/FullTextSearchService';\n\nimport { ICodebaseIndex, RefreshIndex } from '@lib/interface/Indexer';\nimport { IndexTag, MarkCompleteCallback } from '@lib/interface/Tag';\nimport { LastModifiedMap } from '@lib/interface/Types';\n\nexport class FullTextSearchIndex implements ICodebaseIndex {\n  private ftservice: FullTextSearchService;\n  private artifactId: string = 'sqliteFts';\n\n  constructor() {\n    this.ftservice = new FullTextSearchService();\n  }\n\n  public getArtifactId() {\n    return this.artifactId;\n  }\n\n  public async *update(_: IndexTag, subResult: RefreshIndex, identifier: string, markComplete: MarkCompleteCallback) {\n    const indexingProcess = this.ftservice.processIndexing(subResult, markComplete);\n\n    try {\n      for await (const progress of indexingProcess) {\n        yield progress;\n      }\n    } catch (error) {\n      // console.error('Error during fts index process:', error);\n    }\n  }\n\n  public async identifyChanges(\n    tag: IndexTag,\n    currentFiles: LastModifiedMap,\n    identifier: string,\n    refresh: boolean,\n  ): Promise<any> {\n    return await this.ftservice.identifyChanges(tag, currentFiles, identifier, refresh);\n  }\n}\n","import { Table, Column, Model, DataType } from 'sequelize-typescript';\n\n@Table({ tableName: 'CodeSnippet' })\nexport class CodeSnippet extends Model {\n  @Column({ type: DataType.TEXT, allowNull: false })\n  declare path: string;\n\n  @Column({ type: DataType.TEXT, allowNull: false })\n  declare cacheKey: string;\n\n  @Column({ type: DataType.TEXT, allowNull: false })\n  declare content: string;\n\n  @Column({ type: DataType.TEXT, allowNull: false })\n  declare title: string;\n\n  @Column({ type: DataType.TEXT, allowNull: true })\n  declare signature: string;\n\n  @Column({ type: DataType.INTEGER, allowNull: false })\n  declare startLine: number;\n\n  @Column({ type: DataType.INTEGER, allowNull: false })\n  declare endLine: number;\n}\n","import { Table, Column, Model, DataType, ForeignKey } from 'sequelize-typescript';\nimport { CodeSnippet } from './CodeSnippet';\n\n@Table({ tableName: 'CodeSnippetTag' })\nexport class CodeSnippetTag extends Model {\n  @Column({ type: DataType.TEXT, allowNull: false })\n  declare tag: string;\n\n  @ForeignKey(() => CodeSnippet)\n  @Column({ type: DataType.INTEGER, allowNull: false })\n  declare snippetId: number;\n}\n","import { NonNullFindOptions, Attributes, Transaction, Op, Sequelize } from 'sequelize';\n\nimport { BaseRepository } from './BaseRepository';\n\nimport { CodeSnippetTag } from '@lib/model/orm/CodeSnippetTag';\nimport { CodeSnippet } from '@lib/model/orm/CodeSnippet';\nimport { PathAndCacheKey } from '@lib/interface/Types';\n\nexport class CodeSnippetRepository extends BaseRepository {\n  public async getAll(\n    attributes?: string[],\n    conditions?: Record<string, string>,\n    raw: boolean = false,\n    transaction: Transaction | null = null,\n  ) {\n    const options: NonNullFindOptions<Attributes<CodeSnippet>> = this.getFindOptions(attributes, conditions, raw);\n\n    return await CodeSnippet.findAll({ ...options, transaction });\n  }\n\n  private async add(snippet: Partial<CodeSnippet>, options = {}) {\n    return await CodeSnippet.create(snippet, options);\n  }\n\n  private async addSnippetTag(snippetTag: Partial<CodeSnippetTag>, options = {}) {\n    await CodeSnippetTag.create(snippetTag, options);\n  }\n\n  public async addSnippetAndTag(\n    snippets: Partial<CodeSnippet>[],\n    pathAndCacheKey: PathAndCacheKey,\n    tag: string,\n  ): Promise<void> {\n    const transaction = await CodeSnippet.sequelize?.transaction();\n    try {\n      for (const snippet of snippets) {\n        const createdSnippet = await this.add({ ...snippet, ...pathAndCacheKey }, { transaction });\n        await this.addSnippetTag({ snippetId: createdSnippet.id, tag }, { transaction });\n      }\n      await transaction?.commit();\n    } catch (error) {\n      await transaction?.rollback();\n      throw error;\n    }\n  }\n\n  public async deleteSnippetsandTags(pathAndCacheKey: PathAndCacheKey) {\n    const transaction = await CodeSnippet.sequelize?.transaction();\n    try {\n      const snippetsToDel = await this.getIds(pathAndCacheKey, transaction);\n      await this.deleteSnippetTag({ snippetId: { [Op.in]: snippetsToDel } }, transaction);\n      await this.deleteSnippet({ id: { [Op.in]: snippetsToDel } }, transaction);\n      await transaction?.commit();\n    } catch (error) {\n      await transaction?.rollback();\n      throw error;\n    }\n  }\n\n  public async deleteSnippets(pathAndCacheKey: PathAndCacheKey) {\n    const snippetsToDel = await this.getIds(pathAndCacheKey);\n    await this.deleteSnippet({ snippetId: { [Op.in]: snippetsToDel } });\n  }\n\n  private async deleteSnippetTag(conditions: Record<string, any>, transaction: Transaction | null = null) {\n    await CodeSnippetTag.destroy({ where: conditions, transaction });\n  }\n\n  private async deleteSnippet(conditions: Record<string, any>, transaction: Transaction | null = null) {\n    await CodeSnippet.destroy({ where: conditions, transaction });\n  }\n\n  private async getIds(pathAndCacheKey: PathAndCacheKey, transaction: Transaction | null = null) {\n    return await this.getAll(['id'], pathAndCacheKey, true, transaction).then((snippets) =>\n      snippets.map((snippet) => snippet.id),\n    );\n  }\n\n  public async getByPathPattern(\n    conditions: string,\n    bindValues: string[],\n    limit: number,\n    offset: number,\n  ): Promise<CodeSnippet[]> {\n    try {\n      return await CodeSnippet.findAll({\n        where: Sequelize.literal(conditions),\n        replacements: bindValues,\n        limit,\n        offset,\n        order: [\n          ['path', 'ASC'],\n          ['signature', 'ASC'],\n        ],\n      });\n    } catch (error) {\n      throw new Error('Error fetching snippets: ' + error);\n    }\n  }\n}\n","import Parser from '@cs/tree-sitter';\nimport { read, getBasePath } from '@cs/context-utils';\n\nimport { AbstractCodebaseService } from './AbstractCodebaseService';\nimport { CodeSnippetRepository } from '@lib/repository/orm/CodeSnippetRepository';\nimport { Tag } from '@lib/model/orm/Tag';\n\nimport { IndexProgressUpdate, IndexType, RefreshIndex, SnippetChunk, SyncSnippet } from '@lib/interface/Indexer';\nimport { PathsAndSignatures } from '@lib/interface/RepoMap';\n\nconst MAX_LIKE_PATTERN_LENGTH = 50000;\n\nexport class CodeSnippetService extends AbstractCodebaseService {\n  private snippetRepo: CodeSnippetRepository;\n  constructor() {\n    super();\n    this.snippetRepo = new CodeSnippetRepository();\n  }\n\n  public async *sync(syncContext: SyncSnippet) {\n    yield* this.processSnippetTags(IndexType.Compute, syncContext);\n    yield* this.processSnippetTags(IndexType.AddTag, syncContext);\n    yield* this.processSnippetTags(IndexType.RemoveTag, syncContext);\n    yield* this.processSnippetTags(IndexType.Delete, syncContext);\n  }\n\n  private async *processSnippetTags(\n    indexType: IndexType,\n    syncContext: SyncSnippet,\n  ): AsyncGenerator<IndexProgressUpdate> {\n    let { refreshIndex, tagString, markComplete, accumulatedProgress } = syncContext;\n    const tags = refreshIndex[indexType as keyof RefreshIndex];\n\n    if (!tags.length) {\n      return;\n    }\n\n    for (const tag of tags) {\n      const pathAndCacheKey = { path: tag.path, cacheKey: tag.cacheKey };\n      try {\n        switch (indexType) {\n          case IndexType.AddTag:\n          case IndexType.Compute:\n            await this.computeAndAddTag(tag, tagString);\n            break;\n          case IndexType.RemoveTag:\n            await this.snippetRepo.deleteSnippets(pathAndCacheKey);\n            break;\n          case IndexType.Delete:\n            await this.snippetRepo.deleteSnippetsandTags(pathAndCacheKey);\n            break;\n          default:\n            throw new Error(`Unsupported index type: ${indexType}`);\n        }\n\n        await markComplete([tag], indexType);\n        accumulatedProgress += 1 / tags.length / 4;\n\n        yield {\n          progress: accumulatedProgress,\n          status: 'indexing',\n          desc: `${indexType} ${getBasePath(tag.path)}`,\n        };\n      } catch (error) {\n        // console.log(error);\n        throw new Error(`Failed to process tag: ${tag.path} for index type: ${indexType}`);\n      }\n    }\n  }\n\n  private async computeAndAddTag(tag: Tag, tagString: string) {\n    try {\n      const snippets = await this.getSnippetsInFile(tag.path);\n      const pathAndCacheKey = { path: tag.path, cacheKey: tag.cacheKey };\n      await this.snippetRepo.addSnippetAndTag(snippets, pathAndCacheKey, tagString);\n    } catch (e) {\n      // If can't parse, assume malformatted code\n      // console.error(`Error parsing ${tag.path}:`, e);\n    }\n  }\n\n  private async getSnippetsInFile(filepath: string): Promise<SnippetChunk[]> {\n    const contents = await read(filepath);\n    const fileParser = await Parser.buildParserForFile(filepath);\n\n    if (!fileParser) {\n      return [];\n    }\n\n    const ast = fileParser.parse(contents);\n    const query = await Parser.loadQueryForFile(filepath);\n    const matches = query?.matches(ast.rootNode);\n    if (!matches) {\n      return [];\n    }\n\n    return matches.map(this.getSnippetsFromMatch);\n  }\n\n  private getSnippetsFromMatch(match: any): SnippetChunk {\n    const bodyTypesToTreatAsSignatures = [\n      'interface_declaration', // TypeScript, Java\n      'struct_item', // Rust\n      'type_spec', // Go\n    ];\n\n    const bodyCaptureGroupPrefixes = ['definition', 'reference'];\n\n    let title = '',\n      content = '',\n      signature = '',\n      startLine = 0,\n      endLine = 0,\n      hasSeenBody = false;\n\n    // This loop assumes that the ordering of the capture groups is represenatative\n    // of the structure of the language, e.g. for a TypeScript match on a function,\n    // `function myFunc(param: string): string`, the first capture would be the `myFunc`\n    // the second capture would be the `(param: string)`, etc\n    for (const { name, node } of match.captures) {\n      // Assume we are capturing groups using a dot syntax for more precise groupings\n      // However, for this case, we only care about the first substring\n      const trimmedCaptureName = name.split('.')[0];\n\n      const nodeText = node.text;\n      const nodeType = node.type;\n\n      if (bodyCaptureGroupPrefixes.includes(trimmedCaptureName)) {\n        if (bodyTypesToTreatAsSignatures.includes(nodeType)) {\n          // Note we override whatever existing value there is here\n          signature = nodeText;\n          hasSeenBody = true;\n        }\n\n        content = nodeText;\n        startLine = node.startPosition.row;\n        endLine = node.endPosition.row;\n      } else {\n        if (trimmedCaptureName === 'name') {\n          title = nodeText;\n        }\n\n        if (!hasSeenBody) {\n          signature += nodeText + ' ';\n\n          if (trimmedCaptureName === 'comment') {\n            signature += '\\n';\n          }\n        }\n      }\n    }\n\n    return { title, content, signature, startLine, endLine };\n  }\n\n  private truncateToLastNBytes(input: string): string {\n    let bytes = 0;\n    let startIndex = 0;\n\n    for (let i = input.length - 1; i >= 0; i--) {\n      bytes += new TextEncoder().encode(input[i]).length;\n      if (bytes > MAX_LIKE_PATTERN_LENGTH) {\n        startIndex = i + 1;\n        break;\n      }\n    }\n\n    return input.substring(startIndex, input.length);\n  }\n\n  public async getPathsAndSignatures(\n    workspaceDirs: string[],\n    offset: number,\n    batchSize: number,\n  ): Promise<PathsAndSignatures> {\n    const likePatterns = workspaceDirs.map((dir) => this.truncateToLastNBytes(`${dir}%`));\n    const placeholders = likePatterns.map(() => 'path LIKE ?').join(' OR ');\n    const rows = await this.snippetRepo.getByPathPattern(placeholders, likePatterns, batchSize, offset);\n    const groupedByPath: { [path: string]: string[] } = {};\n\n    for (const { path, signature } of rows) {\n      if (!groupedByPath[path]) {\n        groupedByPath[path] = [];\n      }\n      groupedByPath[path].push(signature);\n    }\n    const hasMore = rows.length === batchSize;\n\n    return { groupedByPath, hasMore };\n  }\n}\n","import { CodeSnippetService } from '@lib/service/CodeSnippetService';\n\nimport { IndexTag, MarkCompleteCallback } from '@lib/interface/Tag';\nimport { LastModifiedMap } from '@lib/interface/Types';\nimport { ICodebaseIndex, IndexProgressUpdate, RefreshIndex } from '@lib/interface/Indexer';\n\nexport class CodeSnippetIndex implements ICodebaseIndex {\n  private artifactId = 'codeSnippets';\n  private codeSnippetService: CodeSnippetService;\n\n  constructor() {\n    this.codeSnippetService = new CodeSnippetService();\n  }\n\n  public async *update(\n    tag: IndexTag,\n    refreshIndex: RefreshIndex,\n    _: string,\n    markComplete: MarkCompleteCallback,\n  ): AsyncGenerator<IndexProgressUpdate, any, unknown> {\n    const tagString = this.codeSnippetService.tagToString(tag);\n    let accumulatedProgress = 0;\n    try {\n      for await (const progress of this.codeSnippetService.sync({\n        refreshIndex,\n        tagString,\n        markComplete,\n        accumulatedProgress,\n      })) {\n        yield {\n          desc: progress.desc,\n          progress: progress.progress,\n          status: 'indexing',\n        };\n      }\n    } catch (error) {\n      // console.error('Error during snippet index process:', error);\n    }\n  }\n\n  getArtifactId(): string {\n    return this.artifactId;\n  }\n\n  public async identifyChanges(tag: IndexTag, currentFiles: LastModifiedMap, identifier: string, refresh: boolean) {\n    return await this.codeSnippetService.identifyChanges(tag, currentFiles, identifier, refresh);\n  }\n\n  public async getPathsAndSignatures(workspaceDirs: string[], offset: number = 0, batchSize: number = 100) {\n    return await this.codeSnippetService.getPathsAndSignatures(workspaceDirs, offset, batchSize);\n  }\n}\n","import ChildProcess, { AsyncQueue } from '@cs/process-monitor';\nimport { isJson } from '@cs/context-utils';\n\nexport async function yieldProcess(...arg: any[]) {\n  const command = process.execPath; // To know the path to the Node.js binary\n  const args = ['--expose-gc', ...arg];\n  const queue = new AsyncQueue<string>();\n  const options = {\n    collect: false,\n    onStdout: async (text: string) => {\n      queue.push(parseResponse(text));\n    },\n    onStderr: (err: string) => {\n      console.error('[stderr]', err);\n    },\n    onExit: () => {\n      // Progress close will resolve all unresolved promises of child threads invoked during multithread process\n      // Removing this will cause, for loop to never end in the parent / calling functions\n      queue.close();\n    },\n  };\n\n  const childProcess = new ChildProcess(command, args, options);\n\n  childProcess.run().catch((err: any) => {\n    queue.close();\n    // console.error('Process failed', err);\n  });\n\n  return queue;\n}\n\nconst parseResponse = (text: string) => {\n  const match = text.match(/data:\\s*'([^']+)'/);\n  if (match && isJson(match[1])) {\n    return match[1];\n  }\n\n  return text;\n};\n","export const INDEXER_SCRIPT = ['index', 'refresh'];\n\nexport const STATUS = {\n  done: 'done',\n  complete: 'complete',\n};\n","import { v4 as uuidv4 } from 'uuid';\n\nimport config from '@cs/context-config';\nimport {\n  getLastModified,\n  collectAllFiles,\n  getWorkspaceDir,\n  writeStats,\n  traverseAndClean,\n  hasRequiredCpuFeaturesForLanceDb,\n  getScriptPath,\n} from '@cs/context-utils';\n\nimport { ChunkCodeIndex } from './core/ChunkCodeIndex';\nimport { VectorIndex } from './core/VectorIndex';\nimport { FullTextSearchIndex } from './core/FullTextSearchIndex';\nimport { CodeSnippetIndex } from './core/CodeSnippetIndex';\nimport { GlobalCacheCodeBaseIndex } from './core/GlobalCacheCodeBaseIndex';\nimport { yieldProcess } from '@lib/service/Process';\n\nimport { IndexTag } from '@lib/interface/Tag';\nimport {\n  ICodebaseIndex,\n  IndexProgressUpdate,\n  IndexStatus,\n  IndexType,\n  LatestChunk,\n  ProgressUpdate,\n  RefreshIndex,\n} from '@lib/interface/Indexer';\nimport { STATUS } from '@lib/constant/Process';\n\nconst INDEX_EXPIRATION_DAYS = 30;\n\nexport class CodebaseIndexer {\n  private ignoreRules: string;\n  private globalIndexer: GlobalCacheCodeBaseIndex;\n  private static instance: CodebaseIndexer;\n\n  constructor(protected readonly rules: string = '') {\n    this.ignoreRules = rules;\n    this.globalIndexer = new GlobalCacheCodeBaseIndex();\n  }\n\n  public static getInstance(rules: string = ''): CodebaseIndexer {\n    if (!CodebaseIndexer.instance) {\n      CodebaseIndexer.instance = new CodebaseIndexer(rules);\n    }\n    return CodebaseIndexer.instance;\n  }\n\n  /**\n   * We batch for two reasons:\n   * - To limit memory usage for indexes that perform computations locally, e.g. FTS\n   * - To make as few requests as possible to the embeddings providers\n   */\n  filesPerBatch = 50;\n\n  // Note that we exclude certain Sqlite errors that we do not want to clear the indexes on,\n  // e.g. a `SQLITE_BUSY` error.\n  errorsRegexesToClearIndexesOn = [\n    /Invalid argument error: Values length (d+) is less than the length ((d+)) multiplied by the value size (d+)/,\n    /SQLITE_CONSTRAINT/,\n    /SQLITE_ERROR/,\n    /SQLITE_CORRUPT/,\n    /SQLITE_IOERR/,\n    /SQLITE_FULL/,\n  ];\n\n  public houseKeeping(days: number = INDEX_EXPIRATION_DAYS) {\n    traverseAndClean(days, 'index');\n  }\n\n  private async getIndexesToBuild(): Promise<ICodebaseIndex[]> {\n    const maxChunkSize = config.getConfig().embeddingProvider.maxChunkSize;\n    const indexes = [\n      new ChunkCodeIndex(maxChunkSize), // Chunking must come first\n      ...(hasRequiredCpuFeaturesForLanceDb() ? [new VectorIndex(maxChunkSize)] : []), // Use the vector index only\n      // if the system has a supported CPU for LanceDB\n      new FullTextSearchIndex(),\n      new CodeSnippetIndex(),\n    ];\n\n    return indexes;\n  }\n\n  public async isIndexed(workspaceDir: string, branch: string): Promise<LatestChunk | {}> {\n    return await this.globalIndexer.getLatestChunk(workspaceDir, branch);\n  }\n\n  /**\n   * Enables the indexing operation to be completed in batches, this is important in large\n   * repositories where indexing can quickly use up all the memory available\n   */\n  private *batchRefreshIndex(results: RefreshIndex): Generator<RefreshIndex> {\n    let curPos = 0;\n    while (\n      curPos < results.compute.length ||\n      curPos < results.del.length ||\n      curPos < results.addTag.length ||\n      curPos < results.removeTag.length\n    ) {\n      yield {\n        compute: results.compute.slice(curPos, curPos + this.filesPerBatch),\n        del: results.del.slice(curPos, curPos + this.filesPerBatch),\n        addTag: results.addTag.slice(curPos, curPos + this.filesPerBatch),\n        removeTag: results.removeTag.slice(curPos, curPos + this.filesPerBatch),\n      };\n      curPos += this.filesPerBatch;\n    }\n  }\n\n  private async *runScript(scriptName: string, workspaceDir: string, workspace: string[], branch: string) {\n    const scriptPath = getScriptPath();\n    const progress = await yieldProcess(\n      scriptPath,\n      scriptName,\n      JSON.stringify([this.ignoreRules]), // Constructor Args\n      JSON.stringify([workspaceDir, workspace, branch, uuidv4()]), // Method Args\n      JSON.stringify(config.getAppConfig()), // Config to initialize\n    );\n\n    for await (const update of progress) {\n      yield update;\n    }\n  }\n\n  public async *refresh(workspaceDir: string, workspace: string[], branch: string) {\n    const appConfig = config.getAppConfig();\n    const funcToCall = appConfig?.multiThread\n      ? this.runScript('refresh', workspaceDir, workspace, branch)\n      : this.doRefresh(workspaceDir, workspace, branch, uuidv4());\n    yield* funcToCall;\n  }\n\n  public async *index(workspaceDir: string, workspace: string[], branch: string) {\n    const appConfig = config.getAppConfig();\n    const funcToCall = appConfig?.multiThread\n      ? this.runScript('index', workspaceDir, workspace, branch)\n      : this.doIndex(workspaceDir, workspace, branch, uuidv4());\n    yield* funcToCall;\n  }\n\n  public async *doRefresh(workspaceDir: string, workspace: string[], branch: string, identifier: string) {\n    for await (const progress of this.indexFiles(workspaceDir, workspace, branch, identifier, true)) {\n      yield progress;\n    }\n  }\n\n  private async getFilesToIndex(\n    workspaceDir: string,\n    workspace: string[],\n    artifactId: string,\n    identifier: string,\n  ): Promise<string[]> {\n    const isCacheDone = await this.globalIndexer.getCompleted(identifier, artifactId);\n    // Return empty array since it's already cached for current process\n    if (isCacheDone.length > 0) {\n      return [];\n    }\n    const files: string[] = collectAllFiles(workspace, workspaceDir, this.ignoreRules);\n    const index = await this.globalIndexer.get(identifier, artifactId);\n    const indexPaths = new Set(index.map((entry) => entry.path));\n\n    return files.filter((filePath) => !indexPaths.has(filePath));\n  }\n\n  public async *doIndex(workspaceDir: string, workspace: string[], branch: string, identifier: string) {\n    for await (const progress of this.indexFiles(workspaceDir, workspace, branch, identifier)) {\n      yield progress;\n    }\n  }\n\n  private async *indexFiles(\n    workspaceDir: string,\n    workspace: string[],\n    branch: string,\n    identifier: string,\n    refresh: boolean = false,\n  ): AsyncGenerator<ProgressUpdate> {\n    const indexesToBuild = await this.getIndexesToBuild();\n    let completedIndexCount = 0;\n    let progress = 0;\n    for (const codebaseIndex of indexesToBuild) {\n      const workspaceFiles: string[] = await this.getFilesToIndex(\n        workspaceDir,\n        workspace,\n        codebaseIndex.getArtifactId(),\n        identifier,\n      );\n      if (workspaceFiles.length === 0) {\n        // Skip if all index files are already cached\n        continue;\n      }\n\n      const stats = await getLastModified(workspaceFiles);\n      const tag: IndexTag = {\n        dir: workspaceDir,\n        branch,\n        artifactId: codebaseIndex.getArtifactId(),\n      };\n      // console.log(`Started indexing ${codebaseIndex.getArtifactId()}...`);\n      const planningProgress: IndexProgressUpdate = {\n        progress: progress,\n        desc: `Planning changes for ${codebaseIndex.getArtifactId()} index...`,\n        status: 'indexing',\n      };\n      // yield { data: JSON.stringify(planningProgress) };\n      const [refreshIndex, lastUpdated, markComplete] = await codebaseIndex.identifyChanges(\n        tag,\n        { ...stats },\n        identifier,\n        refresh,\n      );\n      const totalOps =\n        refreshIndex.compute.length +\n        refreshIndex.del.length +\n        refreshIndex.addTag.length +\n        refreshIndex.removeTag.length;\n      let completedOps = 0;\n\n      // Don't update if nothing to update. Some of the indices might do unnecessary setup work\n      if (totalOps > 0) {\n        for (const subResult of this.batchRefreshIndex(refreshIndex)) {\n          for await (const progress of codebaseIndex.update(tag, subResult, identifier, markComplete)) {\n            // Commenting yield to reduce the amt of logs\n            // const indexProgress: IndexProgressUpdate = {\n            //   progress: progress.progress,\n            //   desc: progress.desc,\n            //   status: 'indexing',\n            // };\n            // yield { data: JSON.stringify(indexProgress) };\n          }\n          completedOps +=\n            subResult.compute.length + subResult.del.length + subResult.addTag.length + subResult.removeTag.length;\n          progress = (completedIndexCount + completedOps / totalOps) * (1 / indexesToBuild.length);\n        }\n      }\n\n      await markComplete(lastUpdated, IndexType.UpdateLastUpdated);\n      // Update the status after each indexer. Since indexing/refresh indexing runs as a separate script,\n      // this helps prevent re-running previously failed indexer files for the current process,\n      // which is identified by the `identifier` argument.\n      // Reprocessing those files would unnecessarily consume CPU and memory,\n      // leading to overall delays in the indexing process.\n      await markComplete([{ cacheKey: identifier, artifactId: codebaseIndex.getArtifactId() }], IndexType.StatusUpdate);\n      const indexTrackCnt = await this.globalIndexer.getCompletedCount(identifier);\n      const indexDoneStatus: IndexProgressUpdate = {\n        progress: (indexTrackCnt / indexesToBuild.length) * 100,\n        desc: `Done indexing ${codebaseIndex.getArtifactId()}...`,\n        status: STATUS.done as IndexStatus,\n      };\n      yield { data: JSON.stringify(indexDoneStatus) };\n      console.log(`Finished indexing ${codebaseIndex.getArtifactId()}...`);\n      completedIndexCount += 1;\n    }\n    // console.log(`Completed indexing...`);\n\n    writeStats({ workspaceDir: getWorkspaceDir(), lastIndexedAt: Date.now(), version: 'v1' });\n    const indexCompleteStatus: IndexProgressUpdate = {\n      progress: 1,\n      desc: 'indexing completed',\n      status: STATUS.complete as IndexStatus,\n    };\n    yield { data: JSON.stringify(indexCompleteStatus) };\n  }\n}\n","import { Chunk } from './Chunk';\nimport { ChunkTag } from './ChunkTag';\nimport { CodeSnippet } from './CodeSnippet';\nimport { CodeSnippetTag } from './CodeSnippetTag';\nimport { Fts } from './Fts';\nimport { FtsMetadata } from './FtsMetadata';\nimport { GlobalCache } from './GlobalCache';\nimport { LanceCache } from './LanceCache';\nimport { Tag } from './Tag';\nimport { CacheReport } from './CacheReport';\n\nexport default [\n  Chunk,\n  ChunkTag,\n  CodeSnippet,\n  CodeSnippetTag,\n  Fts,\n  FtsMetadata,\n  GlobalCache,\n  LanceCache,\n  Tag,\n  CacheReport,\n];\n","import { Sequelize, SequelizeOptions } from 'sequelize-typescript';\nimport { getIndexSqlitePath } from '@cs/context-utils';\n\nimport { AbstractDatabase } from './AbstractDatabase';\nimport models from '@lib/model/orm';\n\nexport class Sqlite extends AbstractDatabase {\n  private models: any[] = [];\n\n  public async connect(dbPath: string = getIndexSqlitePath()): Promise<void> {\n    try {\n      this.models = models;\n      const options: SequelizeOptions = {\n        dialect: 'sqlite',\n        models: this.models,\n        storage: dbPath,\n        query: {\n          raw: true,\n        },\n        logging: false,\n      };\n      this.db = new Sequelize(options);\n      await this.setUp();\n      this.logSuccess();\n    } catch (e: any) {\n      this.logFailure(e);\n    }\n  }\n\n  private async setUp() {\n    await this.loadModels();\n\n    const db = this.get();\n    await db?.query('PRAGMA compile_options;');\n    await db?.query(`CREATE VIRTUAL TABLE IF NOT EXISTS Fts USING fts5(\n        id UNINDEXED,\n        path,\n        content,\n        cacheKey,\n        createdAt,\n        updatedAt,\n        tokenize = 'trigram'\n    )`);\n    await db?.query('PRAGMA journal_mode = WAL;');\n  }\n\n  private async loadModels() {\n    await Promise.all(\n      this.models.map(async (model) => {\n        if (model.skipSync) {\n          return;\n        }\n        await model.sync();\n      }),\n    );\n  }\n}\n","import process from 'process';\n\nimport { CodebaseIndexer } from '@lib/indexer/CodebaseIndexer';\nimport { init } from '..';\nimport { IndexerType } from '@lib/interface/Indexer';\n\ntype ConstructorArgs = [string];\ntype MethodArgs = [string, string[], string, string];\n\nexport async function runIndexer(method: 'doIndex' | 'doRefresh', useRetryCheck: boolean = false) {\n  const constructorArgs: ConstructorArgs = JSON.parse(process.argv[3] || '[]');\n  const methodArgs: MethodArgs = JSON.parse(process.argv[4] || '[]');\n  const config = JSON.parse(process.argv[5] || '[]');\n  await init(config);\n  const indexer = CodebaseIndexer.getInstance(...constructorArgs);\n  const shouldUseRefresh = method === 'doRefresh' || (useRetryCheck && process.argv[5]);\n  const methodToCall = shouldUseRefresh ? 'doRefresh' : 'doIndex';\n\n  for await (const progress of indexer[methodToCall](...methodArgs)) {\n    console.log(progress);\n  }\n}\n\nexport const indexer: IndexerType = {\n  async index() {\n    await runIndexer('doIndex', true);\n  },\n  async refresh() {\n    await runIndexer('doRefresh');\n  },\n};\n","import config from '@cs/context-config';\nimport { retrieve } from './context/Retriever';\nimport { CodebaseIndexer } from './indexer/CodebaseIndexer';\nimport { CodeSnippetIndex } from './indexer/core/CodeSnippetIndex';\nimport { Sqlite } from './lib/database/Sqlite';\nimport { indexer } from './script/indexer';\n\nimport { INDEXER_SCRIPT } from './constant/Process';\nimport { IndexerType } from './interface/Indexer';\n\nconst db = new Sqlite();\n\nexport const init = async (appConfig: any = {}) => {\n  config.loadAppConfig(appConfig);\n  await db.connect();\n  // console.log('Database connected!');\n};\n\nexport { CodebaseIndexer, retrieve, CodeSnippetIndex };\n\nconst script = process.argv[2] as keyof IndexerType;\n(async () => {\n  if (INDEXER_SCRIPT.includes(script)) {\n    try {\n      await indexer[script]();\n    } catch (err: any) {\n      console.log(`Failed to execute ${script}`, err);\n    }\n  }\n})();\n"]}