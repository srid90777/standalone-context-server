{"version":3,"sources":["../../src/BaseEmbeddingProvider.ts","../../src/TransformerEmbeddingProvider.ts","../../src/EmbeddingFactory.ts","../../src/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { EmbeddingsProvider, EmbeddingsProviderName, EmbedOptions } from './interface/Embedding';\n\nconst DEFAULT_MAX_CHUNK_SIZE = 500;\n\nexport interface IBaseEmbeddingsProvider extends EmbeddingsProvider {\n  options: EmbedOptions;\n  defaultOptions?: EmbedOptions;\n  maxBatchSize?: number;\n}\n\nexport abstract class BaseEmbeddingProvider {\n  static maxBatchSize: IBaseEmbeddingsProvider['maxBatchSize'];\n\n  static model: IBaseEmbeddingsProvider['options']['model'];\n\n  static defaultOptions: IBaseEmbeddingsProvider['defaultOptions'];\n\n  static providerName: EmbeddingsProviderName;\n\n  public abstract embed(chunks: string[]): Promise<number[][]>;\n  public abstract getProviderName(): string;\n\n  options: IBaseEmbeddingsProvider['options'];\n\n  constructor(options: IBaseEmbeddingsProvider['options']) {\n    this.options = {\n      ...(this.constructor as typeof BaseEmbeddingProvider).defaultOptions,\n      ...options,\n    };\n  }\n\n  public get maxBatchSize(): number | undefined {\n    return this.options.maxBatchSize ?? (this.constructor as typeof BaseEmbeddingProvider).maxBatchSize;\n  }\n\n  public get maxChunkSize(): number {\n    return this.options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  public getModel() {\n    return this.options.model ?? (this.constructor as typeof BaseEmbeddingProvider).model;\n  }\n\n  public getBatchedChunks(chunks: string[]): string[][] {\n    if (!this.maxBatchSize) {\n      console.log(`${this.getBatchedChunks.name} should only be called if 'maxBatchSize' is defined`);\n\n      return [chunks];\n    }\n\n    const batchedChunks = [];\n\n    for (let i = 0; i < chunks.length; i += this.maxBatchSize) {\n      batchedChunks.push(chunks.slice(i, i + this.maxBatchSize));\n    }\n\n    return batchedChunks;\n  }\n}\n","import { BaseEmbeddingProvider } from './BaseEmbeddingProvider';\nimport { EmbeddingsProviderName } from './interface/Embedding';\n\nexport class TransformerEmbeddingProvider extends BaseEmbeddingProvider {\n  static providerName: EmbeddingsProviderName = 'transformers';\n\n  static maxGroupSize: number = 4;\n\n  static model: string = 'Xenova/all-MiniLM-L6-v2';\n\n  static mockVector: number[] = Array.from({ length: 384 }).fill(2) as number[];\n\n  static task: string = 'feature-extraction';\n\n  static instance: any | null = null;\n\n  static pipeline: any | null = null;\n\n  static async initialize() {\n    if (TransformerEmbeddingProvider.pipeline === null) {\n      const module = await import('@xenova/transformers');\n      TransformerEmbeddingProvider.pipeline = module.pipeline;\n    }\n  }\n\n  public async getInstance() {\n    await TransformerEmbeddingProvider.initialize();\n    if (TransformerEmbeddingProvider.instance === null) {\n      TransformerEmbeddingProvider.instance = await TransformerEmbeddingProvider.pipeline(\n        TransformerEmbeddingProvider.task,\n        this.getModel(),\n      );\n    }\n    return TransformerEmbeddingProvider.instance;\n  }\n\n  public getProviderName() {\n    return TransformerEmbeddingProvider.providerName;\n  }\n\n  public getModel() {\n    const { model } = this.options;\n    return model ? `Xenova/${model}` : TransformerEmbeddingProvider.model;\n  }\n\n  public async embed(chunks: string[]) {\n    if (process.env.NODE_ENV === 'test') {\n      return chunks.map(() => TransformerEmbeddingProvider.mockVector);\n    }\n\n    const extractor = await this.getInstance();\n    if (!extractor) {\n      throw new Error('TransformerJS embeddings pipeline is not initialized');\n    }\n\n    if (chunks.length === 0) {\n      return [];\n    }\n\n    const outputs = [];\n    for (let i = 0; i < chunks.length; i += TransformerEmbeddingProvider.maxGroupSize) {\n      const chunkGroup = chunks.slice(i, i + TransformerEmbeddingProvider.maxGroupSize);\n      const output = await extractor(chunkGroup, {\n        pooling: 'mean',\n        normalize: true,\n      });\n      await new Promise((resolve) => setTimeout(resolve, 10));\n      outputs.push(...output.tolist());\n    }\n    return outputs;\n  }\n}\n","import { BaseEmbeddingProvider } from './BaseEmbeddingProvider';\nimport { TransformerEmbeddingProvider } from './TransformerEmbeddingProvider';\n\nexport const Providers: (typeof BaseEmbeddingProvider)[] = [TransformerEmbeddingProvider];\n\nexport const getEmbeddingProviderClassFromName = (name: string): typeof BaseEmbeddingProvider | undefined =>\n  Providers.find((cls) => cls.providerName === name);\n\nexport class EmbeddingFactory {\n  public static create = (name: string, params?: { [key: string]: any }): BaseEmbeddingProvider => {\n    const embeddingProvider = getEmbeddingProviderClassFromName(name ?? 'transformers') as any;\n    if (!embeddingProvider) {\n      console.log(`Unknown embedding provider ${name}`);\n    }\n    return params ? new embeddingProvider(params) : new embeddingProvider();\n  };\n}\n","import { BaseEmbeddingProvider } from './BaseEmbeddingProvider';\nimport { EmbeddingFactory } from './EmbeddingFactory';\n\nexport default EmbeddingFactory;\nexport { BaseEmbeddingProvider };\n"]}